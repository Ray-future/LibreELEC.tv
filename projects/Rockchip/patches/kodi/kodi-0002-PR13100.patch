From 221d334195f5d603ec1fc5c04abbb683bd7d61fe Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 25 Nov 2017 11:19:58 -0800
Subject: [PATCH 1/9] windowing/gbm: legacy add nullptr checks

---
 xbmc/windowing/gbm/DRMLegacy.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/xbmc/windowing/gbm/DRMLegacy.cpp b/xbmc/windowing/gbm/DRMLegacy.cpp
index 6ce560f6ae20..c38be328c74a 100644
--- a/xbmc/windowing/gbm/DRMLegacy.cpp
+++ b/xbmc/windowing/gbm/DRMLegacy.cpp
@@ -195,10 +195,12 @@ void CDRMLegacy::DestroyDrmLegacy()
   if(m_gbm->surface)
   {
     gbm_surface_destroy(m_gbm->surface);
+    m_gbm->surface = nullptr;
   }
 
   if(m_gbm->dev)
   {
     gbm_device_destroy(m_gbm->dev);
+    m_gbm->dev = nullptr;
   }
 }

From 85bc8d016f9875a36d65aec04784188e6f628cc1 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 25 Nov 2017 11:20:41 -0800
Subject: [PATCH 2/9] windowing/gbm: cleanup includes in GBMUtils

---
 xbmc/windowing/gbm/GBMUtils.cpp | 22 ++++------------------
 xbmc/windowing/gbm/GBMUtils.h   |  5 -----
 2 files changed, 4 insertions(+), 23 deletions(-)

diff --git a/xbmc/windowing/gbm/GBMUtils.cpp b/xbmc/windowing/gbm/GBMUtils.cpp
index 1a99c7475669..ec6bff9a89b8 100644
--- a/xbmc/windowing/gbm/GBMUtils.cpp
+++ b/xbmc/windowing/gbm/GBMUtils.cpp
@@ -18,23 +18,8 @@
  *
  */
 
-#include <errno.h>
-#include <fcntl.h>
-#include <poll.h>
-#include <stdint.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <drm_mode.h>
-#include <EGL/egl.h>
-#include <unistd.h>
-
-#include "WinSystemGbmGLESContext.h"
-#include "guilib/gui3d.h"
-#include "utils/log.h"
-#include "settings/Settings.h"
-
 #include "GBMUtils.h"
+#include "utils/log.h"
 
 bool CGBMUtils::InitGbm(struct gbm *gbm, int hdisplay, int vdisplay)
 {
@@ -65,7 +50,8 @@ void CGBMUtils::DestroyGbm(struct gbm *gbm)
   if(gbm->surface)
   {
     gbm_surface_destroy(gbm->surface);
+    gbm->surface = nullptr;
+    gbm->width = 0;
+    gbm->height = 0;
   }
-
-  gbm->surface = nullptr;
 }
diff --git a/xbmc/windowing/gbm/GBMUtils.h b/xbmc/windowing/gbm/GBMUtils.h
index 7b2412c114bd..358f7b82615b 100644
--- a/xbmc/windowing/gbm/GBMUtils.h
+++ b/xbmc/windowing/gbm/GBMUtils.h
@@ -20,12 +20,7 @@
 
 #pragma once
 
-#include <xf86drm.h>
-#include <xf86drmMode.h>
 #include <gbm.h>
-#include <vector>
-
-#include "guilib/Resolution.h"
 
 struct gbm
 {

From be42b9d7f016c07a6872c1656d0a58f705c1534f Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 25 Nov 2017 11:21:47 -0800
Subject: [PATCH 3/9] windowing/gbm: change format of resolution log

---
 xbmc/windowing/gbm/WinSystemGbm.cpp | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/xbmc/windowing/gbm/WinSystemGbm.cpp b/xbmc/windowing/gbm/WinSystemGbm.cpp
index db99ac22d5f8..82abee570ec1 100644
--- a/xbmc/windowing/gbm/WinSystemGbm.cpp
+++ b/xbmc/windowing/gbm/WinSystemGbm.cpp
@@ -110,12 +110,16 @@ void CWinSystemGbm::UpdateResolutions()
   }
   else
   {
+    CDisplaySettings::GetInstance().ClearCustomResolutions();
+
     for (unsigned int i = 0; i < resolutions.size(); i++)
     {
       g_graphicsContext.ResetOverscan(resolutions[i]);
       CDisplaySettings::GetInstance().AddResolutionInfo(resolutions[i]);
 
-      CLog::Log(LOGNOTICE, "Found resolution for display %d with %dx%d%s @ %f Hz",
+      CLog::Log(LOGNOTICE, "Found resolution %dx%d for display %d with %dx%d%s @ %f Hz",
+                resolutions[i].iWidth,
+                resolutions[i].iHeight,
                 resolutions[i].iScreen,
                 resolutions[i].iScreenWidth,
                 resolutions[i].iScreenHeight,

From a53b7747046f6841873c72f6a7c3350c0bf547e8 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sat, 25 Nov 2017 11:22:31 -0800
Subject: [PATCH 4/9] windowing/gbm: return functions directly

---
 xbmc/windowing/gbm/WinSystemGbm.cpp            | 8 +-------
 xbmc/windowing/gbm/WinSystemGbmGLESContext.cpp | 7 +------
 2 files changed, 2 insertions(+), 13 deletions(-)

diff --git a/xbmc/windowing/gbm/WinSystemGbm.cpp b/xbmc/windowing/gbm/WinSystemGbm.cpp
index 82abee570ec1..8ac751c7a318 100644
--- a/xbmc/windowing/gbm/WinSystemGbm.cpp
+++ b/xbmc/windowing/gbm/WinSystemGbm.cpp
@@ -144,13 +144,7 @@ bool CWinSystemGbm::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool bl
     return false;
   }
 
-  auto ret = m_DRM.SetVideoMode(res);
-  if (!ret)
-  {
-    return false;
-  }
-
-  return true;
+  return m_DRM.SetVideoMode(res);
 }
 
 void CWinSystemGbm::FlipPage(CGLContextEGL *pGLContext)
diff --git a/xbmc/windowing/gbm/WinSystemGbmGLESContext.cpp b/xbmc/windowing/gbm/WinSystemGbmGLESContext.cpp
index bb8b60525096..04e48c39c270 100644
--- a/xbmc/windowing/gbm/WinSystemGbmGLESContext.cpp
+++ b/xbmc/windowing/gbm/WinSystemGbmGLESContext.cpp
@@ -98,12 +98,7 @@ bool CWinSystemGbmGLESContext::DestroyWindowSystem()
   CDVDFactoryCodec::ClearHWAccels();
   VIDEOPLAYER::CRendererFactory::ClearRenderer();
 
-  if (!CWinSystemGbm::DestroyWindowSystem())
-  {
-    return false;
-  }
-
-  return true;
+  return CWinSystemGbm::DestroyWindowSystem();
 }
 
 bool CWinSystemGbmGLESContext::CreateNewWindow(const std::string& name,

From 5e4971d960b6ed991deb330d817a59e5f7eeee35 Mon Sep 17 00:00:00 2001
From: Lukas Rusak <lorusak@gmail.com>
Date: Sat, 25 Nov 2017 11:40:36 -0800
Subject: [PATCH 5/9] windowing/gbm: rework init and remove duplicate code

---
 xbmc/windowing/gbm/DRMLegacy.cpp |   6 +-
 xbmc/windowing/gbm/DRMUtils.cpp  | 318 ++++++++++++++++++++++++++-------------
 xbmc/windowing/gbm/DRMUtils.h    |  29 +++-
 3 files changed, 241 insertions(+), 112 deletions(-)

diff --git a/xbmc/windowing/gbm/DRMLegacy.cpp b/xbmc/windowing/gbm/DRMLegacy.cpp
index c38be328c74a..a07a791bb412 100644
--- a/xbmc/windowing/gbm/DRMLegacy.cpp
+++ b/xbmc/windowing/gbm/DRMLegacy.cpp
@@ -57,11 +57,11 @@ bool CDRMLegacy::SetVideoMode(RESOLUTION_INFO res)
   m_drm_fb = CDRMUtils::DrmFbGetFromBo(m_bo);
 
   auto ret = drmModeSetCrtc(m_drm->fd,
-                            m_drm->crtc_id,
+                            m_drm->crtc->crtc->crtc_id,
                             m_drm_fb->fb_id,
                             0,
                             0,
-                            &m_drm->connector_id,
+                            &m_drm->connector->connector->connector_id,
                             1,
                             m_drm->mode);
 
@@ -144,7 +144,7 @@ bool CDRMLegacy::QueueFlip()
   m_drm_fb = CDRMUtils::DrmFbGetFromBo(m_next_bo);
 
   auto ret = drmModePageFlip(m_drm->fd,
-                             m_drm->crtc_id,
+                             m_drm->crtc->crtc->crtc_id,
                              m_drm_fb->fb_id,
                              DRM_MODE_PAGE_FLIP_EVENT,
                              &flip_happening);
diff --git a/xbmc/windowing/gbm/DRMUtils.cpp b/xbmc/windowing/gbm/DRMUtils.cpp
index 2ce1f3e70ce2..cfea515e63bf 100644
--- a/xbmc/windowing/gbm/DRMUtils.cpp
+++ b/xbmc/windowing/gbm/DRMUtils.cpp
@@ -38,9 +38,6 @@
 static struct drm *m_drm = nullptr;
 
 static drmModeResPtr m_drm_resources = nullptr;
-static drmModePlaneResPtr m_drm_plane_resources = nullptr;
-static drmModeConnectorPtr m_drm_connector = nullptr;
-static drmModeEncoderPtr m_drm_encoder = nullptr;
 static drmModeCrtcPtr m_orig_crtc = nullptr;
 
 struct drm *CDRMUtils::GetDrm()
@@ -58,7 +55,7 @@ void CDRMUtils::WaitVBlank()
 
 bool CDRMUtils::SetMode(RESOLUTION_INFO res)
 {
-  m_drm->mode = &m_drm_connector->modes[atoi(res.strId.c_str())];
+  m_drm->mode = &m_drm->connector->connector->modes[atoi(res.strId.c_str())];
 
   CLog::Log(LOGDEBUG, "CDRMUtils::%s - found crtc mode: %dx%d%s @ %d Hz",
             __FUNCTION__,
@@ -138,12 +135,6 @@ bool CDRMUtils::GetResources()
     return false;
   }
 
-  m_drm_plane_resources = drmModeGetPlaneResources(m_drm->fd);
-  if (!m_drm_plane_resources)
-  {
-    return false;
-  }
-
   return true;
 }
 
@@ -151,23 +142,37 @@ bool CDRMUtils::GetConnector()
 {
   for(auto i = 0; i < m_drm_resources->count_connectors; i++)
   {
-    m_drm_connector = drmModeGetConnector(m_drm->fd,
-                                          m_drm_resources->connectors[i]);
-    if(m_drm_connector->connection == DRM_MODE_CONNECTED)
+    m_drm->connector->connector = drmModeGetConnector(m_drm->fd,
+                                                      m_drm_resources->connectors[i]);
+    if(m_drm->connector->connector->connection == DRM_MODE_CONNECTED)
     {
       CLog::Log(LOGDEBUG, "CDRMUtils::%s - found connector: %d", __FUNCTION__,
-                                                                 m_drm_connector->connector_type);
+                                                                 m_drm->connector->connector->connector_id);
       break;
     }
-    drmModeFreeConnector(m_drm_connector);
-    m_drm_connector = nullptr;
+    drmModeFreeConnector(m_drm->connector->connector);
+    m_drm->connector->connector = nullptr;
+  }
+
+  if(!m_drm->connector->connector)
+  {
+    CLog::Log(LOGERROR, "CDRMUtils::%s - could not get connector: %s", __FUNCTION__, strerror(errno));
+    return false;
   }
 
-  if(!m_drm_connector)
+  m_drm->connector->props = drmModeObjectGetProperties(m_drm->fd, m_drm->connector->connector->connector_id, DRM_MODE_OBJECT_CONNECTOR);
+  if (!m_drm->connector->props)
   {
+    CLog::Log(LOGERROR, "CDRMUtils::%s - could not get connector %u properties: %s", __FUNCTION__, m_drm->connector->connector->connector_id, strerror(errno));
     return false;
   }
 
+  m_drm->connector->props_info = new drmModePropertyPtr;
+  for (uint32_t i = 0; i < m_drm->connector->props->count_props; i++)
+  {
+    m_drm->connector->props_info[i] = drmModeGetProperty(m_drm->fd, m_drm->connector->props->props[i]);
+  }
+
   return true;
 }
 
@@ -175,30 +180,69 @@ bool CDRMUtils::GetEncoder()
 {
   for(auto i = 0; i < m_drm_resources->count_encoders; i++)
   {
-    m_drm_encoder = drmModeGetEncoder(m_drm->fd, m_drm_resources->encoders[i]);
-    if(m_drm_encoder->encoder_id == m_drm_connector->encoder_id)
+    m_drm->encoder->encoder = drmModeGetEncoder(m_drm->fd, m_drm_resources->encoders[i]);
+    if(m_drm->encoder->encoder->encoder_id == m_drm->connector->connector->encoder_id)
     {
       CLog::Log(LOGDEBUG, "CDRMUtils::%s - found encoder: %d", __FUNCTION__,
-                                                               m_drm_encoder->encoder_type);
+                                                               m_drm->encoder->encoder->encoder_id);
+      break;
+    }
+    drmModeFreeEncoder(m_drm->encoder->encoder);
+    m_drm->encoder->encoder = nullptr;
+  }
+
+  if(!m_drm->encoder->encoder)
+  {
+    CLog::Log(LOGERROR, "CDRMUtils::%s - could not get encoder: %s", __FUNCTION__, strerror(errno));
+    return false;
+  }
+
+  return true;
+}
+
+bool CDRMUtils::GetCrtc()
+{
+  for(auto i = 0; i < m_drm_resources->count_crtcs; i++)
+  {
+    m_drm->crtc->crtc = drmModeGetCrtc(m_drm->fd, m_drm_resources->crtcs[i]);
+    if(m_drm->crtc->crtc->crtc_id == m_drm->encoder->encoder->crtc_id)
+    {
+      CLog::Log(LOGDEBUG, "CDRMUtils::%s - found crtc: %d", __FUNCTION__,
+                                                            m_drm->crtc->crtc->crtc_id);
+      m_drm->crtc_index = i;
       break;
     }
-    drmModeFreeEncoder(m_drm_encoder);
-    m_drm_encoder = nullptr;
+    drmModeFreeCrtc(m_drm->crtc->crtc);
+    m_drm->crtc->crtc = nullptr;
+  }
+
+  if(!m_drm->crtc->crtc)
+  {
+    CLog::Log(LOGERROR, "CDRMUtils::%s - could not get crtc: %s", __FUNCTION__, strerror(errno));
+    return false;
   }
 
-  if(!m_drm_encoder)
+  m_drm->crtc->props = drmModeObjectGetProperties(m_drm->fd, m_drm->crtc->crtc->crtc_id, DRM_MODE_OBJECT_CRTC);
+  if (!m_drm->crtc->props)
   {
+    CLog::Log(LOGERROR, "CDRMUtils::%s - could not get crtc %u properties: %s", __FUNCTION__, m_drm->crtc->crtc->crtc_id, strerror(errno));
     return false;
   }
 
+  m_drm->crtc->props_info = new drmModePropertyPtr;
+  for (uint32_t i = 0; i < m_drm->crtc->props->count_props; i++)
+  {
+    m_drm->crtc->props_info[i] = drmModeGetProperty(m_drm->fd, m_drm->crtc->props->props[i]);
+  }
+
   return true;
 }
 
 bool CDRMUtils::GetPreferredMode()
 {
-  for(auto i = 0, area = 0; i < m_drm_connector->count_modes; i++)
+  for(auto i = 0, area = 0; i < m_drm->connector->connector->count_modes; i++)
   {
-    drmModeModeInfo *current_mode = &m_drm_connector->modes[i];
+    drmModeModeInfo *current_mode = &m_drm->connector->connector->modes[i];
 
     if(current_mode->type & DRM_MODE_TYPE_PREFERRED)
     {
@@ -230,9 +274,107 @@ bool CDRMUtils::GetPreferredMode()
   return true;
 }
 
+bool CDRMUtils::GetPlanes()
+{
+  drmModePlaneResPtr plane_resources;
+  uint32_t primary_plane_id = -1;
+  uint32_t overlay_plane_id = -1;
+
+  plane_resources = drmModeGetPlaneResources(m_drm->fd);
+  if (!plane_resources)
+  {
+    CLog::Log(LOGERROR, "CDRMUtils::%s - drmModeGetPlaneResources failed: %s", __FUNCTION__, strerror(errno));
+    return false;
+  }
+
+  for (uint32_t i = 0; i < plane_resources->count_planes; i++)
+  {
+    uint32_t id = plane_resources->planes[i];
+    drmModePlanePtr plane = drmModeGetPlane(m_drm->fd, id);
+    if (!plane)
+    {
+      CLog::Log(LOGERROR, "CDRMUtils::%s - drmModeGetPlane(%u) failed: %s", __FUNCTION__, id, strerror(errno));
+      continue;
+    }
+
+    if (plane->possible_crtcs & (1 << m_drm->crtc_index))
+    {
+      drmModeObjectPropertiesPtr props = drmModeObjectGetProperties(m_drm->fd, id, DRM_MODE_OBJECT_PLANE);
+
+      for (uint32_t j = 0; j < props->count_props; j++)
+      {
+        drmModePropertyPtr p = drmModeGetProperty(m_drm->fd, props->props[j]);
+
+        if ((strcmp(p->name, "type") == 0) && (props->prop_values[j] == DRM_PLANE_TYPE_PRIMARY))
+        {
+          CLog::Log(LOGDEBUG, "CDRMUtils::%s - found primary plane: %d", __FUNCTION__, id);
+          primary_plane_id = id;
+        }
+        else if ((strcmp(p->name, "type") == 0) && (props->prop_values[j] == DRM_PLANE_TYPE_OVERLAY))
+        {
+          CLog::Log(LOGDEBUG, "CDRMUtils::%s - found overlay plane: %d", __FUNCTION__, id);
+          overlay_plane_id = id;
+        }
+
+        drmModeFreeProperty(p);
+      }
+
+      drmModeFreeObjectProperties(props);
+    }
+
+    drmModeFreePlane(plane);
+  }
+
+  drmModeFreePlaneResources(plane_resources);
+
+  // primary plane
+  m_drm->primary_plane->plane = drmModeGetPlane(m_drm->fd, primary_plane_id);
+  if (!m_drm->primary_plane->plane)
+  {
+    CLog::Log(LOGERROR, "CDRMUtils::%s - could not get primary plane %i: %s", __FUNCTION__, primary_plane_id, strerror(errno));
+    return false;
+  }
+
+  m_drm->primary_plane->props = drmModeObjectGetProperties(m_drm->fd, primary_plane_id, DRM_MODE_OBJECT_PLANE);
+  if (!m_drm->primary_plane->props)
+  {
+    CLog::Log(LOGERROR, "CDRMUtils::%s - could not get primary plane %u properties: %s", __FUNCTION__, primary_plane_id, strerror(errno));
+    return false;
+  }
+
+  m_drm->primary_plane->props_info = new drmModePropertyPtr;
+  for (uint32_t i = 0; i < m_drm->primary_plane->props->count_props; i++)
+  {
+    m_drm->primary_plane->props_info[i] = drmModeGetProperty(m_drm->fd, m_drm->primary_plane->props->props[i]);
+  }
+
+  // overlay plane
+  m_drm->overlay_plane->plane = drmModeGetPlane(m_drm->fd, overlay_plane_id);
+  if (!m_drm->overlay_plane->plane)
+  {
+    CLog::Log(LOGERROR, "CDRMUtils::%s - could not get overlay plane %i: %s", __FUNCTION__, overlay_plane_id, strerror(errno));
+    return false;
+  }
+
+  m_drm->overlay_plane->props = drmModeObjectGetProperties(m_drm->fd, overlay_plane_id, DRM_MODE_OBJECT_PLANE);
+  if (!m_drm->overlay_plane->props)
+  {
+    CLog::Log(LOGERROR, "CDRMUtils::%s - could not get overlay plane %u properties: %s", __FUNCTION__, overlay_plane_id, strerror(errno));
+    return false;
+  }
+
+  m_drm->overlay_plane->props_info = new drmModePropertyPtr;
+  for (uint32_t i = 0; i < m_drm->overlay_plane->props->count_props; i++)
+  {
+    m_drm->overlay_plane->props_info[i] = drmModeGetProperty(m_drm->fd, m_drm->overlay_plane->props->props[i]);
+  }
+
+  return true;
+}
+
 int CDRMUtils::Open(const char* device)
 {
-  int fd;
+  int fd = -1;
 
   std::vector<const char*>modules =
   {
@@ -252,23 +394,13 @@ int CDRMUtils::Open(const char* device)
   for (auto module : modules)
   {
     fd = drmOpen(module, device);
-    if (fd < 0)
-    {
-      CLog::Log(LOGDEBUG, "CDRMUtils::%s - failed to open device: %s using module: %s", __FUNCTION__, device, module);
-    }
-    else
+    if (fd >= 0)
     {
       CLog::Log(LOGDEBUG, "CDRMUtils::%s - opened device: %s using module: %s", __FUNCTION__, device, module);
       break;
     }
   }
 
-  if (fd < 0)
-  {
-    CLog::Log(LOGDEBUG, "CDRMUtils::%s - no module found for device: %s", __FUNCTION__, device);
-    return -1;
-  }
-
   return fd;
 }
 
@@ -276,13 +408,24 @@ bool CDRMUtils::InitDrm(drm *drm)
 {
   m_drm = drm;
 
+  m_drm->connector = new connector;
+  m_drm->encoder = new encoder;
+  m_drm->crtc = new crtc;
+  m_drm->primary_plane = new plane;
+  m_drm->overlay_plane = new plane;
+
   for(int i = 0; i < 10; ++i)
   {
+    if (m_drm->fd >= 0)
+    {
+      drmClose(m_drm->fd);
+    }
+
     std::string device = "/dev/dri/card";
     device.append(std::to_string(i));
     m_drm->fd = CDRMUtils::Open(device.c_str());
 
-    if(m_drm->fd > 0)
+    if(m_drm->fd >= 0)
     {
       if(!GetResources())
       {
@@ -298,15 +441,30 @@ bool CDRMUtils::InitDrm(drm *drm)
       {
         continue;
       }
-      else
+
+      if(!GetCrtc())
+      {
+        continue;
+      }
+
+      auto ret = drmSetClientCap(m_drm->fd, DRM_CLIENT_CAP_UNIVERSAL_PLANES, 1);
+      if (ret)
+      {
+        CLog::Log(LOGERROR, "CDRMUtils::%s - failed to set Universal planes capability: %s", __FUNCTION__, strerror(errno));
+        return false;
+      }
+
+      if(!GetPlanes())
       {
-        m_drm->crtc_id = m_drm_encoder->crtc_id;
+        continue;
       }
 
       break;
     }
   }
 
+  drmModeFreeResources(m_drm_resources);
+
   if(m_drm->fd < 0)
   {
     return false;
@@ -317,33 +475,9 @@ bool CDRMUtils::InitDrm(drm *drm)
     return false;
   }
 
-  for(auto i = 0; i < m_drm_resources->count_crtcs; i++)
-  {
-    if(m_drm_resources->crtcs[i] == m_drm->crtc_id)
-    {
-      m_drm->crtc_index = i;
-      break;
-    }
-  }
-
-  m_drm->video_plane_id = 0;
-  for (uint32_t i = 0; i < m_drm_plane_resources->count_planes; i++)
-  {
-    drmModePlane *plane = drmModeGetPlane(m_drm->fd, m_drm_plane_resources->planes[i]);
-    if (!plane)
-      continue;
-    if (!m_drm->video_plane_id && plane->possible_crtcs & (1 << m_drm->crtc_index))
-      m_drm->video_plane_id = plane->plane_id;
-    drmModeFreePlane(plane);
-  }
-
-  drmModeFreePlaneResources(m_drm_plane_resources);
-  drmModeFreeResources(m_drm_resources);
-
   drmSetMaster(m_drm->fd);
 
-  m_drm->connector_id = m_drm_connector->connector_id;
-  m_orig_crtc = drmModeGetCrtc(m_drm->fd, m_drm->crtc_id);
+  m_orig_crtc = drmModeGetCrtc(m_drm->fd, m_drm->crtc->crtc->crtc_id);
 
   return true;
 }
@@ -360,7 +494,7 @@ bool CDRMUtils::RestoreOriginalMode()
                             m_orig_crtc->buffer_id,
                             m_orig_crtc->x,
                             m_orig_crtc->y,
-                            &m_drm->connector_id,
+                            &m_drm->connector->connector->connector_id,
                             1,
                             &m_orig_crtc->mode);
 
@@ -382,22 +516,7 @@ void CDRMUtils::DestroyDrm()
 {
   RestoreOriginalMode();
 
-  if(m_drm_encoder)
-  {
-    drmModeFreeEncoder(m_drm_encoder);
-  }
-
-  if(m_drm_connector)
-  {
-    drmModeFreeConnector(m_drm_connector);
-  }
-
-  if (m_drm_plane_resources)
-  {
-     drmModeFreePlaneResources(m_drm_plane_resources);
-  }
-
-  if(m_drm_resources)
+  if (m_drm_resources)
   {
     drmModeFreeResources(m_drm_resources);
   }
@@ -405,54 +524,49 @@ void CDRMUtils::DestroyDrm()
   drmDropMaster(m_drm->fd);
   close(m_drm->fd);
 
-  m_drm_encoder = nullptr;
-  m_drm_connector = nullptr;
   m_drm_resources = nullptr;
-  m_drm_plane_resources = nullptr;
 
+  m_drm->primary_plane = nullptr;
+  m_drm->overlay_plane = nullptr;
   m_drm->connector = nullptr;
-  m_drm->connector_id = 0;
   m_drm->crtc = nullptr;
-  m_drm->crtc_id = 0;
-  m_drm->crtc_index = 0;
   m_drm->fd = -1;
-  m_drm->video_plane_id = 0;
   m_drm->mode = nullptr;
 }
 
 bool CDRMUtils::GetModes(std::vector<RESOLUTION_INFO> &resolutions)
 {
-  for(auto i = 0; i < m_drm_connector->count_modes; i++)
+  for(auto i = 0; i < m_drm->connector->connector->count_modes; i++)
   {
     RESOLUTION_INFO res;
     res.iScreen = 0;
-    res.iWidth = m_drm_connector->modes[i].hdisplay;
-    res.iHeight = m_drm_connector->modes[i].vdisplay;
-    res.iScreenWidth = m_drm_connector->modes[i].hdisplay;
-    res.iScreenHeight = m_drm_connector->modes[i].vdisplay;
-    if (m_drm_connector->modes[i].clock % 10 != 0)
-      res.fRefreshRate = (float)m_drm_connector->modes[i].vrefresh * (1000.0f/1001.0f);
+    res.iWidth = m_drm->connector->connector->modes[i].hdisplay;
+    res.iHeight = m_drm->connector->connector->modes[i].vdisplay;
+    res.iScreenWidth = m_drm->connector->connector->modes[i].hdisplay;
+    res.iScreenHeight = m_drm->connector->connector->modes[i].vdisplay;
+    if (m_drm->connector->connector->modes[i].clock % 10 != 0)
+      res.fRefreshRate = (float)m_drm->connector->connector->modes[i].vrefresh * (1000.0f/1001.0f);
     else
-      res.fRefreshRate = m_drm_connector->modes[i].vrefresh;
+      res.fRefreshRate = m_drm->connector->connector->modes[i].vrefresh;
     res.iSubtitles = static_cast<int>(0.965 * res.iHeight);
     res.fPixelRatio = 1.0f;
     res.bFullScreen = true;
-    res.strMode = m_drm_connector->modes[i].name;
+    res.strMode = m_drm->connector->connector->modes[i].name;
     res.strId = std::to_string(i);
 
-    if(m_drm_connector->modes[i].flags & DRM_MODE_FLAG_3D_MASK)
+    if(m_drm->connector->connector->modes[i].flags & DRM_MODE_FLAG_3D_MASK)
     {
-      if(m_drm_connector->modes[i].flags & DRM_MODE_FLAG_3D_TOP_AND_BOTTOM)
+      if(m_drm->connector->connector->modes[i].flags & DRM_MODE_FLAG_3D_TOP_AND_BOTTOM)
       {
         res.dwFlags = D3DPRESENTFLAG_MODE3DTB;
       }
-      else if(m_drm_connector->modes[i].flags
+      else if(m_drm->connector->connector->modes[i].flags
           & DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF)
       {
         res.dwFlags = D3DPRESENTFLAG_MODE3DSBS;
       }
     }
-    else if(m_drm_connector->modes[i].flags & DRM_MODE_FLAG_INTERLACE)
+    else if(m_drm->connector->connector->modes[i].flags & DRM_MODE_FLAG_INTERLACE)
     {
       res.dwFlags = D3DPRESENTFLAG_INTERLACED;
     }
diff --git a/xbmc/windowing/gbm/DRMUtils.h b/xbmc/windowing/gbm/DRMUtils.h
index 16d8a495e1ca..3b2aca649963 100644
--- a/xbmc/windowing/gbm/DRMUtils.h
+++ b/xbmc/windowing/gbm/DRMUtils.h
@@ -28,9 +28,9 @@
 #include "guilib/Resolution.h"
 #include "GBMUtils.h"
 
-struct crtc
+struct plane
 {
-  drmModeCrtc *crtc;
+  drmModePlane *plane;
   drmModeObjectProperties *props;
   drmModePropertyRes **props_info;
 };
@@ -42,18 +42,31 @@ struct connector
   drmModePropertyRes **props_info;
 };
 
+struct encoder
+{
+  drmModeEncoder *encoder;
+};
+
+struct crtc
+{
+  drmModeCrtc *crtc;
+  drmModeObjectProperties *props;
+  drmModePropertyRes **props_info;
+};
+
 struct drm
 {
   int fd;
 
-  struct crtc *crtc;
+  struct plane *primary_plane;
+  struct plane *overlay_plane;
   struct connector *connector;
-  int crtc_index;
+  struct encoder *encoder;
+  struct crtc *crtc;
 
   drmModeModeInfo *mode;
-  uint32_t crtc_id;
-  uint32_t connector_id;
-  uint32_t video_plane_id;
+
+  int crtc_index;
 };
 
 struct drm_fb
@@ -79,6 +92,8 @@ class CDRMUtils
   static bool GetResources();
   static bool GetConnector();
   static bool GetEncoder();
+  static bool GetCrtc();
+  static bool GetPlanes();
   static bool GetPreferredMode();
   static int Open(const char* device);
   static bool RestoreOriginalMode();

From c67e26436dcded3ece03349c2ecb2185bb2322a1 Mon Sep 17 00:00:00 2001
From: Lukas Rusak <lorusak@gmail.com>
Date: Sat, 25 Nov 2017 11:43:59 -0800
Subject: [PATCH 6/9] RendererDRMPRIME: use overlay_plane

---
 .../cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.cpp
index 5ea349c0372f..652e1a6f5134 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.cpp
@@ -213,12 +213,12 @@ void CRendererDRMPRIME::SetVideoPlane(CVideoBufferDRMPRIME* buffer)
     // TODO: use atomic or legacy api
 
     // show the video frame FB on the video plane
-    ret = drmModeSetPlane(drm->fd, drm->video_plane_id, drm->crtc_id, buffer->m_fb_id, 0,
+    ret = drmModeSetPlane(drm->fd, drm->overlay_plane->plane->plane_id, drm->crtc->crtc->crtc_id, buffer->m_fb_id, 0,
                           crtc_x, crtc_y, crtc_w, crtc_h,
                           src_x, src_y, src_w, src_h);
     if (ret < 0)
     {
-      CLog::Log(LOGERROR, "CRendererDRMPRIME::%s - failed to set drm plane %d, buffer = %d, ret = %d", __FUNCTION__, drm->video_plane_id, buffer->m_fb_id, ret);
+      CLog::Log(LOGERROR, "CRendererDRMPRIME::%s - failed to set drm plane %d, buffer = %d, ret = %d", __FUNCTION__, drm->overlay_plane->plane->plane_id, buffer->m_fb_id, ret);
       return;
     }
   }

From 294865c78f7ee26e5ed9b4f88f3a95abc1526f29 Mon Sep 17 00:00:00 2001
From: Lukas Rusak <lorusak@gmail.com>
Date: Sat, 25 Nov 2017 21:44:43 -0800
Subject: [PATCH 7/9] windowing/gbm: check supported plane formats

---
 xbmc/windowing/gbm/DRMUtils.cpp | 53 ++++++++++++++++++++++++++++++++++++++++-
 xbmc/windowing/gbm/DRMUtils.h   |  1 +
 2 files changed, 53 insertions(+), 1 deletion(-)

diff --git a/xbmc/windowing/gbm/DRMUtils.cpp b/xbmc/windowing/gbm/DRMUtils.cpp
index cfea515e63bf..6a173baa5af6 100644
--- a/xbmc/windowing/gbm/DRMUtils.cpp
+++ b/xbmc/windowing/gbm/DRMUtils.cpp
@@ -108,7 +108,7 @@ drm_fb * CDRMUtils::DrmFbGetFromBo(struct gbm_bo *bo)
   auto ret = drmModeAddFB2(m_drm->fd,
                            width,
                            height,
-                           DRM_FORMAT_ARGB8888,
+                           m_drm->primary_plane->format,
                            handles,
                            strides,
                            offsets,
@@ -279,6 +279,7 @@ bool CDRMUtils::GetPlanes()
   drmModePlaneResPtr plane_resources;
   uint32_t primary_plane_id = -1;
   uint32_t overlay_plane_id = -1;
+  uint32_t fourcc = 0;
 
   plane_resources = drmModeGetPlaneResources(m_drm->fd);
   if (!plane_resources)
@@ -348,6 +349,30 @@ bool CDRMUtils::GetPlanes()
     m_drm->primary_plane->props_info[i] = drmModeGetProperty(m_drm->fd, m_drm->primary_plane->props->props[i]);
   }
 
+  for (uint32_t i = 0; i < m_drm->primary_plane->plane->count_formats; i++)
+  {
+    /* we want an alpha layer so break if we find one */
+    if (m_drm->primary_plane->plane->formats[i] == DRM_FORMAT_XRGB8888)
+    {
+      fourcc = DRM_FORMAT_XRGB8888;
+      m_drm->primary_plane->format = fourcc;
+    }
+    else if (m_drm->primary_plane->plane->formats[i] == DRM_FORMAT_ARGB8888)
+    {
+      fourcc = DRM_FORMAT_ARGB8888;
+      m_drm->primary_plane->format = fourcc;
+      break;
+    }
+  }
+
+  if (fourcc == 0)
+  {
+    CLog::Log(LOGERROR, "CDRMUtils::%s - could not find a suitable primary plane format", __FUNCTION__);
+    return false;
+  }
+
+  CLog::Log(LOGDEBUG, "CDRMUtils::%s - primary plane format: %c%c%c%c", __FUNCTION__, fourcc, fourcc >> 8, fourcc >> 16, fourcc >> 24);
+
   // overlay plane
   m_drm->overlay_plane->plane = drmModeGetPlane(m_drm->fd, overlay_plane_id);
   if (!m_drm->overlay_plane->plane)
@@ -369,6 +394,32 @@ bool CDRMUtils::GetPlanes()
     m_drm->overlay_plane->props_info[i] = drmModeGetProperty(m_drm->fd, m_drm->overlay_plane->props->props[i]);
   }
 
+  fourcc = 0;
+
+  for (uint32_t i = 0; i < m_drm->overlay_plane->plane->count_formats; i++)
+  {
+    /* we want an alpha layer so break if we find one */
+    if (m_drm->overlay_plane->plane->formats[i] == DRM_FORMAT_XRGB8888)
+    {
+      fourcc = DRM_FORMAT_XRGB8888;
+      m_drm->overlay_plane->format = fourcc;
+    }
+    else if(m_drm->overlay_plane->plane->formats[i] == DRM_FORMAT_ARGB8888)
+    {
+      fourcc = DRM_FORMAT_ARGB8888;
+      m_drm->overlay_plane->format = fourcc;
+      break;
+    }
+  }
+
+  if (fourcc == 0)
+  {
+    CLog::Log(LOGERROR, "CDRMUtils::%s - could not find a suitable overlay plane format", __FUNCTION__);
+    return false;
+  }
+
+  CLog::Log(LOGDEBUG, "CDRMUtils::%s - overlay plane format: %c%c%c%c", __FUNCTION__, fourcc, fourcc >> 8, fourcc >> 16, fourcc >> 24);
+
   return true;
 }
 
diff --git a/xbmc/windowing/gbm/DRMUtils.h b/xbmc/windowing/gbm/DRMUtils.h
index 3b2aca649963..6cc96e5ce856 100644
--- a/xbmc/windowing/gbm/DRMUtils.h
+++ b/xbmc/windowing/gbm/DRMUtils.h
@@ -33,6 +33,7 @@ struct plane
   drmModePlane *plane;
   drmModeObjectProperties *props;
   drmModePropertyRes **props_info;
+  uint32_t format;
 };
 
 struct connector

From e9f57c722033d4fcd489b72437a940c6ad25193b Mon Sep 17 00:00:00 2001
From: Lukas Rusak <lorusak@gmail.com>
Date: Sat, 25 Nov 2017 23:38:57 -0800
Subject: [PATCH 8/9] windowing/gbm: remove passing GLContextEGL

---
 xbmc/windowing/gbm/DRM.cpp                     | 4 ++--
 xbmc/windowing/gbm/DRM.h                       | 2 +-
 xbmc/windowing/gbm/DRMLegacy.cpp               | 2 +-
 xbmc/windowing/gbm/DRMLegacy.h                 | 2 +-
 xbmc/windowing/gbm/WinSystemGbm.cpp            | 4 ++--
 xbmc/windowing/gbm/WinSystemGbm.h              | 2 +-
 xbmc/windowing/gbm/WinSystemGbmGLESContext.cpp | 2 +-
 7 files changed, 9 insertions(+), 9 deletions(-)

diff --git a/xbmc/windowing/gbm/DRM.cpp b/xbmc/windowing/gbm/DRM.cpp
index 0cfc08d10868..de45f1414b00 100644
--- a/xbmc/windowing/gbm/DRM.cpp
+++ b/xbmc/windowing/gbm/DRM.cpp
@@ -23,9 +23,9 @@
 #include "DRM.h"
 #include "DRMLegacy.h"
 
-void CDRM::FlipPage(CGLContextEGL *pGLContext)
+void CDRM::FlipPage()
 {
-  CDRMLegacy::FlipPage(pGLContext);
+  CDRMLegacy::FlipPage();
 }
 
 bool CDRM::SetVideoMode(RESOLUTION_INFO res)
diff --git a/xbmc/windowing/gbm/DRM.h b/xbmc/windowing/gbm/DRM.h
index 870a6fe2b93e..9c027ecaf00e 100644
--- a/xbmc/windowing/gbm/DRM.h
+++ b/xbmc/windowing/gbm/DRM.h
@@ -27,7 +27,7 @@ class CDRM
 {
 public:
   ~CDRM() = default;
-  void FlipPage(CGLContextEGL *pGLContext);
+  void FlipPage();
   bool SetVideoMode(RESOLUTION_INFO res);
   bool InitDrm(drm *drm, gbm *gbm);
   void DestroyDrm();
diff --git a/xbmc/windowing/gbm/DRMLegacy.cpp b/xbmc/windowing/gbm/DRMLegacy.cpp
index a07a791bb412..f995e07d8a0d 100644
--- a/xbmc/windowing/gbm/DRMLegacy.cpp
+++ b/xbmc/windowing/gbm/DRMLegacy.cpp
@@ -158,7 +158,7 @@ bool CDRMLegacy::QueueFlip()
   return true;
 }
 
-void CDRMLegacy::FlipPage(CGLContextEGL *pGLContext)
+void CDRMLegacy::FlipPage()
 {
   if(WaitingForFlip())
   {
diff --git a/xbmc/windowing/gbm/DRMLegacy.h b/xbmc/windowing/gbm/DRMLegacy.h
index 46411f5e187d..9dfa0bb9456a 100644
--- a/xbmc/windowing/gbm/DRMLegacy.h
+++ b/xbmc/windowing/gbm/DRMLegacy.h
@@ -26,7 +26,7 @@
 class CDRMLegacy : public CDRMUtils
 {
 public:
-  static void FlipPage(CGLContextEGL *pGLContext);
+  static void FlipPage();
   static bool SetVideoMode(RESOLUTION_INFO res);
   static bool InitDrmLegacy(drm *drm, gbm *gbm);
   static void DestroyDrmLegacy();
diff --git a/xbmc/windowing/gbm/WinSystemGbm.cpp b/xbmc/windowing/gbm/WinSystemGbm.cpp
index 8ac751c7a318..6be957300600 100644
--- a/xbmc/windowing/gbm/WinSystemGbm.cpp
+++ b/xbmc/windowing/gbm/WinSystemGbm.cpp
@@ -147,9 +147,9 @@ bool CWinSystemGbm::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool bl
   return m_DRM.SetVideoMode(res);
 }
 
-void CWinSystemGbm::FlipPage(CGLContextEGL *pGLContext)
+void CWinSystemGbm::FlipPage()
 {
-  m_DRM.FlipPage(pGLContext);
+  m_DRM.FlipPage();
 }
 
 void CWinSystemGbm::WaitVBlank()
diff --git a/xbmc/windowing/gbm/WinSystemGbm.h b/xbmc/windowing/gbm/WinSystemGbm.h
index 149987a22b58..2d29c932fc27 100644
--- a/xbmc/windowing/gbm/WinSystemGbm.h
+++ b/xbmc/windowing/gbm/WinSystemGbm.h
@@ -48,7 +48,7 @@ class CWinSystemGbm : public CWinSystemBase
   bool ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop) override;
   bool SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays) override;
 
-  void FlipPage(CGLContextEGL *m_pGLContext);
+  void FlipPage();
   void WaitVBlank();
 
   void UpdateResolutions() override;
diff --git a/xbmc/windowing/gbm/WinSystemGbmGLESContext.cpp b/xbmc/windowing/gbm/WinSystemGbmGLESContext.cpp
index 04e48c39c270..ddb54c507c43 100644
--- a/xbmc/windowing/gbm/WinSystemGbmGLESContext.cpp
+++ b/xbmc/windowing/gbm/WinSystemGbmGLESContext.cpp
@@ -165,7 +165,7 @@ void CWinSystemGbmGLESContext::PresentRender(bool rendered, bool videoLayer)
   if (rendered)
   {
     m_pGLContext.SwapBuffers();
-    CWinSystemGbm::FlipPage(&m_pGLContext);
+    CWinSystemGbm::FlipPage();
   }
   else
   {

From c66771507a80516fb0404a0cd230e42e2114e020 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sun, 3 Dec 2017 16:13:11 +0100
Subject: [PATCH 9/9] windowing/gbm: rework surface buffer lock and release

---
 xbmc/windowing/gbm/DRMLegacy.cpp | 37 +++++++++++++++++--------------------
 xbmc/windowing/gbm/GBMUtils.cpp  |  3 +++
 xbmc/windowing/gbm/GBMUtils.h    |  9 ++++++---
 3 files changed, 26 insertions(+), 23 deletions(-)

diff --git a/xbmc/windowing/gbm/DRMLegacy.cpp b/xbmc/windowing/gbm/DRMLegacy.cpp
index f995e07d8a0d..b082e2cfbef7 100644
--- a/xbmc/windowing/gbm/DRMLegacy.cpp
+++ b/xbmc/windowing/gbm/DRMLegacy.cpp
@@ -39,11 +39,6 @@
 static struct drm *m_drm = nullptr;
 static struct gbm *m_gbm = nullptr;
 
-static struct drm_fb *m_drm_fb = new drm_fb;
-
-static struct gbm_bo *m_bo = nullptr;
-static struct gbm_bo *m_next_bo = nullptr;
-
 static int flip_happening = 0;
 
 static struct pollfd m_drm_fds;
@@ -51,14 +46,12 @@ static drmEventContext m_drm_evctx;
 
 bool CDRMLegacy::SetVideoMode(RESOLUTION_INFO res)
 {
-  gbm_surface_release_buffer(m_gbm->surface, m_bo);
-
-  m_bo = gbm_surface_lock_front_buffer(m_gbm->surface);
-  m_drm_fb = CDRMUtils::DrmFbGetFromBo(m_bo);
+  m_gbm->next_bo = gbm_surface_lock_front_buffer(m_gbm->surface);
+  struct drm_fb *drm_fb = CDRMUtils::DrmFbGetFromBo(m_gbm->next_bo);
 
   auto ret = drmModeSetCrtc(m_drm->fd,
                             m_drm->crtc->crtc->crtc_id,
-                            m_drm_fb->fb_id,
+                            drm_fb->fb_id,
                             0,
                             0,
                             &m_drm->connector->connector->connector_id,
@@ -85,6 +78,10 @@ bool CDRMLegacy::SetVideoMode(RESOLUTION_INFO res)
             m_drm->mode->flags & DRM_MODE_FLAG_INTERLACE ? "i" : "",
             m_drm->mode->vrefresh);
 
+  gbm_surface_release_buffer(m_gbm->surface, m_gbm->bo);
+  m_gbm->bo = m_gbm->next_bo;
+  m_gbm->next_bo = nullptr;
+
   return true;
 }
 
@@ -132,20 +129,21 @@ bool CDRMLegacy::WaitingForFlip()
     }
   }
 
-  gbm_surface_release_buffer(m_gbm->surface, m_bo);
-  m_bo = m_next_bo;
+  gbm_surface_release_buffer(m_gbm->surface, m_gbm->bo);
+  m_gbm->bo = m_gbm->next_bo;
+  m_gbm->next_bo = nullptr;
 
   return false;
 }
 
 bool CDRMLegacy::QueueFlip()
 {
-  m_next_bo = gbm_surface_lock_front_buffer(m_gbm->surface);
-  m_drm_fb = CDRMUtils::DrmFbGetFromBo(m_next_bo);
+  m_gbm->next_bo = gbm_surface_lock_front_buffer(m_gbm->surface);
+  struct drm_fb *drm_fb = CDRMUtils::DrmFbGetFromBo(m_gbm->next_bo);
 
   auto ret = drmModePageFlip(m_drm->fd,
                              m_drm->crtc->crtc->crtc_id,
-                             m_drm_fb->fb_id,
+                             drm_fb->fb_id,
                              DRM_MODE_PAGE_FLIP_EVENT,
                              &flip_happening);
 
@@ -160,12 +158,8 @@ bool CDRMLegacy::QueueFlip()
 
 void CDRMLegacy::FlipPage()
 {
-  if(WaitingForFlip())
-  {
-    return;
-  }
-
   flip_happening = QueueFlip();
+  WaitingForFlip();
 }
 
 bool CDRMLegacy::InitDrmLegacy(drm *drm, gbm *gbm)
@@ -194,6 +188,9 @@ void CDRMLegacy::DestroyDrmLegacy()
 
   if(m_gbm->surface)
   {
+    gbm_surface_release_buffer(m_gbm->surface, m_gbm->bo);
+    m_gbm->bo = m_gbm->next_bo = nullptr;
+
     gbm_surface_destroy(m_gbm->surface);
     m_gbm->surface = nullptr;
   }
diff --git a/xbmc/windowing/gbm/GBMUtils.cpp b/xbmc/windowing/gbm/GBMUtils.cpp
index ec6bff9a89b8..481959939435 100644
--- a/xbmc/windowing/gbm/GBMUtils.cpp
+++ b/xbmc/windowing/gbm/GBMUtils.cpp
@@ -49,6 +49,9 @@ void CGBMUtils::DestroyGbm(struct gbm *gbm)
 {
   if(gbm->surface)
   {
+    gbm_surface_release_buffer(gbm->surface, gbm->bo);
+    gbm->bo = gbm->next_bo = nullptr;
+
     gbm_surface_destroy(gbm->surface);
     gbm->surface = nullptr;
     gbm->width = 0;
diff --git a/xbmc/windowing/gbm/GBMUtils.h b/xbmc/windowing/gbm/GBMUtils.h
index 358f7b82615b..287a2bb7e2eb 100644
--- a/xbmc/windowing/gbm/GBMUtils.h
+++ b/xbmc/windowing/gbm/GBMUtils.h
@@ -24,9 +24,12 @@
 
 struct gbm
 {
-  struct gbm_device *dev;
-  struct gbm_surface *surface;
-  int width, height;
+  struct gbm_device *dev = nullptr;
+  struct gbm_surface *surface = nullptr;
+  struct gbm_bo *bo = nullptr;
+  struct gbm_bo *next_bo = nullptr;
+  int width = 0;
+  int height = 0;
 };
 
 class CGBMUtils
