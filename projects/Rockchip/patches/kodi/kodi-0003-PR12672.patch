From 9c682fb3210b37210ce49465d36c594e65d790fe Mon Sep 17 00:00:00 2001
From: Lukas Rusak <lorusak@gmail.com>
Date: Tue, 10 Oct 2017 18:21:45 -0700
Subject: [PATCH] windowing/gbm: add atomic modesetting

---
 xbmc/windowing/gbm/CMakeLists.txt   |   2 +
 xbmc/windowing/gbm/DRM.cpp          |  41 +++++-
 xbmc/windowing/gbm/DRM.h            |   4 +
 xbmc/windowing/gbm/DRMAtomic.cpp    | 256 ++++++++++++++++++++++++++++++++++++
 xbmc/windowing/gbm/DRMAtomic.h      |  38 ++++++
 xbmc/windowing/gbm/DRMUtils.cpp     |  29 ++--
 xbmc/windowing/gbm/DRMUtils.h       |   4 +
 xbmc/windowing/gbm/GBMUtils.cpp     |   3 +-
 xbmc/windowing/gbm/GLContextEGL.cpp |   1 -
 xbmc/windowing/gbm/GLContextEGL.h   |   3 +-
 10 files changed, 365 insertions(+), 16 deletions(-)
 create mode 100644 xbmc/windowing/gbm/DRMAtomic.cpp
 create mode 100644 xbmc/windowing/gbm/DRMAtomic.h

diff --git a/xbmc/windowing/gbm/CMakeLists.txt b/xbmc/windowing/gbm/CMakeLists.txt
index 800e2927b9b8..12655e7cc268 100644
--- a/xbmc/windowing/gbm/CMakeLists.txt
+++ b/xbmc/windowing/gbm/CMakeLists.txt
@@ -3,6 +3,7 @@ set(SOURCES GLContextEGL.cpp
             GBMUtils.cpp
             DRMUtils.cpp
             DRMLegacy.cpp
+            DRMAtomic.cpp
             DRM.cpp)
 
 set(HEADERS GLContextEGL.h
@@ -10,6 +11,7 @@ set(HEADERS GLContextEGL.h
             GBMUtils.h
             DRMUtils.h
             DRMLegacy.h
+            DRMAtomic.h
             DRM.h)
 
 if(OPENGLES_FOUND)
diff --git a/xbmc/windowing/gbm/DRM.cpp b/xbmc/windowing/gbm/DRM.cpp
index de45f1414b00..7324ee580a41 100644
--- a/xbmc/windowing/gbm/DRM.cpp
+++ b/xbmc/windowing/gbm/DRM.cpp
@@ -21,21 +21,47 @@
 #include "utils/log.h"
 
 #include "DRM.h"
+#include "DRMAtomic.h"
 #include "DRMLegacy.h"
 
+CDRM::CDRM()
+  : m_atomic(false)
+{
+}
+
 void CDRM::FlipPage()
 {
-  CDRMLegacy::FlipPage();
+  if (m_atomic)
+  {
+    CDRMAtomic::FlipPage();
+  }
+  else
+  {
+    CDRMLegacy::FlipPage();
+  }
 }
 
 bool CDRM::SetVideoMode(RESOLUTION_INFO res)
 {
-  return CDRMLegacy::SetVideoMode(res);
+  if (m_atomic)
+  {
+    return CDRMAtomic::SetVideoMode(res);
+  }
+  else
+  {
+    return CDRMLegacy::SetVideoMode(res);
+  }
 }
 
 bool CDRM::InitDrm(drm *drm, gbm *gbm)
 {
-  if (CDRMLegacy::InitDrmLegacy(drm, gbm))
+  if (CDRMAtomic::InitDrmAtomic(drm, gbm))
+  {
+    m_atomic = true;
+    CLog::Log(LOGNOTICE, "CDRM::%s - initialized Atomic DRM", __FUNCTION__);
+    return true;
+  }
+  else if (CDRMLegacy::InitDrmLegacy(drm, gbm))
   {
     CLog::Log(LOGNOTICE, "CDRM::%s - initialized Legacy DRM", __FUNCTION__);
     return true;
@@ -46,5 +72,12 @@ bool CDRM::InitDrm(drm *drm, gbm *gbm)
 
 void CDRM::DestroyDrm()
 {
-  CDRMLegacy::DestroyDrmLegacy();
+  if (m_atomic)
+  {
+    CDRMAtomic::DestroyDrmAtomic();
+  }
+  else
+  {
+    CDRMLegacy::DestroyDrmLegacy();
+  }
 }
diff --git a/xbmc/windowing/gbm/DRM.h b/xbmc/windowing/gbm/DRM.h
index 9c027ecaf00e..5317396b48e7 100644
--- a/xbmc/windowing/gbm/DRM.h
+++ b/xbmc/windowing/gbm/DRM.h
@@ -26,9 +26,13 @@
 class CDRM
 {
 public:
+  CDRM();
   ~CDRM() = default;
   void FlipPage();
   bool SetVideoMode(RESOLUTION_INFO res);
   bool InitDrm(drm *drm, gbm *gbm);
   void DestroyDrm();
+
+private:
+  bool m_atomic;
 };
diff --git a/xbmc/windowing/gbm/DRMAtomic.cpp b/xbmc/windowing/gbm/DRMAtomic.cpp
new file mode 100644
index 000000000000..e5f98e7680d0
--- /dev/null
+++ b/xbmc/windowing/gbm/DRMAtomic.cpp
@@ -0,0 +1,256 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <errno.h>
+#include <drm_mode.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "settings/Settings.h"
+#include "utils/log.h"
+
+#include "DRMAtomic.h"
+#include "WinSystemGbmGLESContext.h"
+
+static struct drm *m_drm = nullptr;
+static struct gbm *m_gbm = nullptr;
+
+bool CDRMAtomic::AddConnectorProperty(drmModeAtomicReq *req, int obj_id, const char *name, int value)
+{
+  struct connector *obj = m_drm->connector;
+  int prop_id = 0;
+
+  for (unsigned int i = 0 ; i < obj->props->count_props ; i++)
+  {
+    if (strcmp(obj->props_info[i]->name, name) == 0)
+    {
+      prop_id = obj->props_info[i]->prop_id;
+      break;
+    }
+  }
+
+  if (prop_id < 0)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - no connector property: %s", __FUNCTION__, name);
+    return false;
+  }
+
+  auto ret = drmModeAtomicAddProperty(req, obj_id, prop_id, value);
+  if (ret < 0)
+  {
+    return false;
+  }
+
+  return true;
+}
+
+bool CDRMAtomic::AddCrtcProperty(drmModeAtomicReq *req, int obj_id, const char *name, int value)
+{
+  struct crtc *obj = m_drm->crtc;
+  int prop_id = -1;
+
+  for (unsigned int i = 0 ; i < obj->props->count_props ; i++)
+  {
+    if (strcmp(obj->props_info[i]->name, name) == 0)
+    {
+      prop_id = obj->props_info[i]->prop_id;
+      break;
+    }
+  }
+
+  if (prop_id < 0)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - no crtc property: %s", __FUNCTION__, name);
+    return false;
+  }
+
+  auto ret = drmModeAtomicAddProperty(req, obj_id, prop_id, value);
+  if (ret < 0)
+  {
+    return false;
+  }
+
+  return true;
+}
+
+bool CDRMAtomic::AddPlaneProperty(drmModeAtomicReq *req, struct plane *obj, const char *name, int value)
+{
+  int prop_id = -1;
+
+  for (unsigned int i = 0 ; i < obj->props->count_props ; i++)
+  {
+    if (strcmp(obj->props_info[i]->name, name) == 0)
+    {
+      prop_id = obj->props_info[i]->prop_id;
+      break;
+    }
+  }
+
+  if (prop_id < 0)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - no plane property: %s", __FUNCTION__, name);
+    return false;
+  }
+
+  auto ret = drmModeAtomicAddProperty(req, obj->plane->plane_id, prop_id, value);
+  if (ret < 0)
+  {
+    return false;
+  }
+
+  return true;
+}
+
+bool CDRMAtomic::DrmAtomicCommit(int fb_id, int flags)
+{
+  uint32_t blob_id;
+
+  if (flags & DRM_MODE_ATOMIC_ALLOW_MODESET)
+  {
+    if (!AddConnectorProperty(m_drm->req, m_drm->connector->connector->connector_id, "CRTC_ID", m_drm->crtc->crtc->crtc_id))
+    {
+      return false;
+    }
+
+    if (drmModeCreatePropertyBlob(m_drm->fd, m_drm->mode, sizeof(*m_drm->mode), &blob_id) != 0)
+    {
+      return false;
+    }
+
+    if (!AddCrtcProperty(m_drm->req, m_drm->crtc->crtc->crtc_id, "MODE_ID", blob_id))
+    {
+      return false;
+    }
+
+    if (!AddCrtcProperty(m_drm->req, m_drm->crtc->crtc->crtc_id, "ACTIVE", 1))
+    {
+      return false;
+    }
+  }
+
+  AddPlaneProperty(m_drm->req, m_drm->primary_plane, "FB_ID", fb_id);
+  AddPlaneProperty(m_drm->req, m_drm->primary_plane, "CRTC_ID", m_drm->crtc->crtc->crtc_id);
+  AddPlaneProperty(m_drm->req, m_drm->primary_plane, "SRC_X", 0);
+  AddPlaneProperty(m_drm->req, m_drm->primary_plane, "SRC_Y", 0);
+  AddPlaneProperty(m_drm->req, m_drm->primary_plane, "SRC_W", m_drm->mode->hdisplay << 16);
+  AddPlaneProperty(m_drm->req, m_drm->primary_plane, "SRC_H", m_drm->mode->vdisplay << 16);
+  AddPlaneProperty(m_drm->req, m_drm->primary_plane, "CRTC_X", 0);
+  AddPlaneProperty(m_drm->req, m_drm->primary_plane, "CRTC_Y", 0);
+  AddPlaneProperty(m_drm->req, m_drm->primary_plane, "CRTC_W", m_drm->mode->hdisplay);
+  AddPlaneProperty(m_drm->req, m_drm->primary_plane, "CRTC_H", m_drm->mode->vdisplay);
+
+  auto ret = drmModeAtomicCommit(m_drm->fd, m_drm->req, flags, nullptr);
+  if (ret)
+  {
+    return false;
+  }
+
+  drmModeAtomicFree(m_drm->req);
+
+  m_drm->req = drmModeAtomicAlloc();
+
+  return true;
+}
+
+void CDRMAtomic::FlipPage()
+{
+  uint32_t flags = 0;
+
+  if(m_drm->need_modeset)
+  {
+    flags |= DRM_MODE_ATOMIC_ALLOW_MODESET;
+    m_drm->need_modeset = false;
+  }
+
+  gbm_surface_release_buffer(m_gbm->surface, m_gbm->bo);
+  m_gbm->bo = m_gbm->next_bo;
+
+  m_gbm->next_bo = gbm_surface_lock_front_buffer(m_gbm->surface);
+  if (!m_gbm->next_bo)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - Failed to lock frontbuffer", __FUNCTION__);
+    return;
+  }
+
+  struct drm_fb *drm_fb = CDRMUtils::DrmFbGetFromBo(m_gbm->next_bo);
+  if (!drm_fb)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - Failed to get a new FBO", __FUNCTION__);
+    return;
+  }
+
+  auto ret = DrmAtomicCommit(drm_fb->fb_id, flags);
+  if (!ret) {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - failed to commit: %s", __FUNCTION__, strerror(errno));
+    return;
+  }
+}
+
+bool CDRMAtomic::InitDrmAtomic(drm *drm, gbm *gbm)
+{
+  m_drm = drm;
+  m_gbm = gbm;
+
+  m_drm->req = drmModeAtomicAlloc();
+
+  if (!CDRMUtils::InitDrm(m_drm))
+  {
+    return false;
+  }
+
+  m_gbm->dev = gbm_create_device(m_drm->fd);
+
+  if (!CGBMUtils::InitGbm(m_gbm, m_drm->mode->hdisplay, m_drm->mode->vdisplay))
+  {
+    return false;
+  }
+
+  return true;
+}
+
+void CDRMAtomic::DestroyDrmAtomic()
+{
+  gbm_surface_release_buffer(m_gbm->surface, m_gbm->bo);
+  m_gbm->bo = m_gbm->next_bo = nullptr;
+
+  CDRMUtils::DestroyDrm();
+
+  if(m_gbm->surface)
+  {
+    gbm_surface_destroy(m_gbm->surface);
+    m_gbm->surface = nullptr;
+  }
+
+  if(m_gbm->dev)
+  {
+    gbm_device_destroy(m_gbm->dev);
+    m_gbm->dev = nullptr;
+  }
+
+  drmModeAtomicFree(m_drm->req);
+  m_drm->req = nullptr;
+}
+
+bool CDRMAtomic::SetVideoMode(RESOLUTION_INFO res)
+{
+  m_drm->need_modeset = true;
+
+  return true;
+}
diff --git a/xbmc/windowing/gbm/DRMAtomic.h b/xbmc/windowing/gbm/DRMAtomic.h
new file mode 100644
index 000000000000..eaeaa9e194c1
--- /dev/null
+++ b/xbmc/windowing/gbm/DRMAtomic.h
@@ -0,0 +1,38 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#include "DRMUtils.h"
+
+class CDRMAtomic : public CDRMUtils
+{
+public:
+  static void FlipPage();
+  static bool SetVideoMode(RESOLUTION_INFO res);
+  static bool InitDrmAtomic(drm *drm, gbm *gbm);
+  static void DestroyDrmAtomic();
+
+private:
+  static bool AddConnectorProperty(drmModeAtomicReq *req, int obj_id, const char *name, int value);
+  static bool AddCrtcProperty(drmModeAtomicReq *req, int obj_id, const char *name, int value);
+  static bool AddPlaneProperty(drmModeAtomicReq *req, struct plane *obj, const char *name, int value);
+  static bool DrmAtomicCommit(int fb_id, int flags);
+};
diff --git a/xbmc/windowing/gbm/DRMUtils.cpp b/xbmc/windowing/gbm/DRMUtils.cpp
index 6a173baa5af6..8ce0b273a6b4 100644
--- a/xbmc/windowing/gbm/DRMUtils.cpp
+++ b/xbmc/windowing/gbm/DRMUtils.cpp
@@ -478,6 +478,24 @@ bool CDRMUtils::InitDrm(drm *drm)
 
     if(m_drm->fd >= 0)
     {
+      /* caps need to be set before allocating connectors, encoders, crtcs, and planes */
+      auto ret = drmSetClientCap(m_drm->fd, DRM_CLIENT_CAP_UNIVERSAL_PLANES, 1);
+      if (ret)
+      {
+        CLog::Log(LOGERROR, "CDRMUtils::%s - failed to set Universal planes capability: %s", __FUNCTION__, strerror(errno));
+        return false;
+      }
+
+      if (m_drm->req)
+      {
+        auto ret = drmSetClientCap(m_drm->fd, DRM_CLIENT_CAP_ATOMIC, 1);
+        if (ret)
+        {
+          CLog::Log(LOGERROR, "CDRMUtils::%s - no atomic modesetting support: %s", __FUNCTION__, strerror(errno));
+          return false;
+        }
+      }
+
       if(!GetResources())
       {
         continue;
@@ -498,13 +516,6 @@ bool CDRMUtils::InitDrm(drm *drm)
         continue;
       }
 
-      auto ret = drmSetClientCap(m_drm->fd, DRM_CLIENT_CAP_UNIVERSAL_PLANES, 1);
-      if (ret)
-      {
-        CLog::Log(LOGERROR, "CDRMUtils::%s - failed to set Universal planes capability: %s", __FUNCTION__, strerror(errno));
-        return false;
-      }
-
       if(!GetPlanes())
       {
         continue;
@@ -570,13 +581,13 @@ void CDRMUtils::DestroyDrm()
   if (m_drm_resources)
   {
     drmModeFreeResources(m_drm_resources);
+    m_drm_resources = nullptr;
+
   }
 
   drmDropMaster(m_drm->fd);
   close(m_drm->fd);
 
-  m_drm_resources = nullptr;
-
   m_drm->primary_plane = nullptr;
   m_drm->overlay_plane = nullptr;
   m_drm->connector = nullptr;
diff --git a/xbmc/windowing/gbm/DRMUtils.h b/xbmc/windowing/gbm/DRMUtils.h
index 6cc96e5ce856..4bc1191c395f 100644
--- a/xbmc/windowing/gbm/DRMUtils.h
+++ b/xbmc/windowing/gbm/DRMUtils.h
@@ -68,6 +68,10 @@ struct drm
   drmModeModeInfo *mode;
 
   int crtc_index;
+
+  bool need_modeset;
+
+  drmModeAtomicReq *req;
 };
 
 struct drm_fb
diff --git a/xbmc/windowing/gbm/GBMUtils.cpp b/xbmc/windowing/gbm/GBMUtils.cpp
index 481959939435..94331dfa7906 100644
--- a/xbmc/windowing/gbm/GBMUtils.cpp
+++ b/xbmc/windowing/gbm/GBMUtils.cpp
@@ -49,7 +49,8 @@ void CGBMUtils::DestroyGbm(struct gbm *gbm)
 {
   if(gbm->surface)
   {
-    gbm_surface_release_buffer(gbm->surface, gbm->bo);
+    if (gbm->bo)
+      gbm_surface_release_buffer(gbm->surface, gbm->bo);
     gbm->bo = gbm->next_bo = nullptr;
 
     gbm_surface_destroy(gbm->surface);
diff --git a/xbmc/windowing/gbm/GLContextEGL.cpp b/xbmc/windowing/gbm/GLContextEGL.cpp
index 392080ba830f..36d4ae669cb2 100644
--- a/xbmc/windowing/gbm/GLContextEGL.cpp
+++ b/xbmc/windowing/gbm/GLContextEGL.cpp
@@ -24,7 +24,6 @@
 #include "settings/AdvancedSettings.h"
 #include "utils/log.h"
 
-#include <EGL/eglext.h>
 #include <string.h>
 
 CGLContextEGL::CGLContextEGL() :
diff --git a/xbmc/windowing/gbm/GLContextEGL.h b/xbmc/windowing/gbm/GLContextEGL.h
index afea42950e87..b66c7bcacd88 100644
--- a/xbmc/windowing/gbm/GLContextEGL.h
+++ b/xbmc/windowing/gbm/GLContextEGL.h
@@ -20,7 +20,8 @@
 
 #pragma once
 
-#include "EGL/egl.h"
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
 
 class CGLContextEGL
 {
