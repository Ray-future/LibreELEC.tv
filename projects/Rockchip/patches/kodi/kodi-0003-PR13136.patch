From 40fad937fdb705c3ece56bc8bb5a02cb5ffc6d21 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Sun, 3 Dec 2017 17:13:06 +0100
Subject: [PATCH 1/3] windowing/gbm: move code to GBMUtils

---
 xbmc/windowing/gbm/DRMLegacy.cpp    | 41 +++++++---------------
 xbmc/windowing/gbm/GBMUtils.cpp     | 68 ++++++++++++++++++++++++++++++++-----
 xbmc/windowing/gbm/GBMUtils.h       | 10 ++++--
 xbmc/windowing/gbm/WinSystemGbm.cpp |  6 ++--
 4 files changed, 82 insertions(+), 43 deletions(-)

diff --git a/xbmc/windowing/gbm/DRMLegacy.cpp b/xbmc/windowing/gbm/DRMLegacy.cpp
index b082e2cfbef7..046db31ccbe5 100644
--- a/xbmc/windowing/gbm/DRMLegacy.cpp
+++ b/xbmc/windowing/gbm/DRMLegacy.cpp
@@ -46,8 +46,8 @@ static drmEventContext m_drm_evctx;
 
 bool CDRMLegacy::SetVideoMode(RESOLUTION_INFO res)
 {
-  m_gbm->next_bo = gbm_surface_lock_front_buffer(m_gbm->surface);
-  struct drm_fb *drm_fb = CDRMUtils::DrmFbGetFromBo(m_gbm->next_bo);
+  struct gbm_bo *bo = CGBMUtils::LockFrontBuffer(m_gbm);
+  struct drm_fb *drm_fb = CDRMUtils::DrmFbGetFromBo(bo);
 
   auto ret = drmModeSetCrtc(m_drm->fd,
                             m_drm->crtc->crtc->crtc_id,
@@ -78,9 +78,7 @@ bool CDRMLegacy::SetVideoMode(RESOLUTION_INFO res)
             m_drm->mode->flags & DRM_MODE_FLAG_INTERLACE ? "i" : "",
             m_drm->mode->vrefresh);
 
-  gbm_surface_release_buffer(m_gbm->surface, m_gbm->bo);
-  m_gbm->bo = m_gbm->next_bo;
-  m_gbm->next_bo = nullptr;
+  CGBMUtils::ReleaseBuffer(m_gbm);
 
   return true;
 }
@@ -129,17 +127,13 @@ bool CDRMLegacy::WaitingForFlip()
     }
   }
 
-  gbm_surface_release_buffer(m_gbm->surface, m_gbm->bo);
-  m_gbm->bo = m_gbm->next_bo;
-  m_gbm->next_bo = nullptr;
-
   return false;
 }
 
 bool CDRMLegacy::QueueFlip()
 {
-  m_gbm->next_bo = gbm_surface_lock_front_buffer(m_gbm->surface);
-  struct drm_fb *drm_fb = CDRMUtils::DrmFbGetFromBo(m_gbm->next_bo);
+  struct gbm_bo *bo = CGBMUtils::LockFrontBuffer(m_gbm);
+  struct drm_fb *drm_fb = CDRMUtils::DrmFbGetFromBo(bo);
 
   auto ret = drmModePageFlip(m_drm->fd,
                              m_drm->crtc->crtc->crtc_id,
@@ -160,6 +154,7 @@ void CDRMLegacy::FlipPage()
 {
   flip_happening = QueueFlip();
   WaitingForFlip();
+  CGBMUtils::ReleaseBuffer(m_gbm);
 }
 
 bool CDRMLegacy::InitDrmLegacy(drm *drm, gbm *gbm)
@@ -172,9 +167,12 @@ bool CDRMLegacy::InitDrmLegacy(drm *drm, gbm *gbm)
     return false;
   }
 
-  m_gbm->dev = gbm_create_device(m_drm->fd);
+  if (!CGBMUtils::CreateDevice(m_gbm, m_drm->fd))
+  {
+    return false;
+  }
 
-  if (!CGBMUtils::InitGbm(m_gbm, m_drm->mode->hdisplay, m_drm->mode->vdisplay))
+  if (!CGBMUtils::CreateSurface(m_gbm, m_drm->mode->hdisplay, m_drm->mode->vdisplay))
   {
     return false;
   }
@@ -184,20 +182,7 @@ bool CDRMLegacy::InitDrmLegacy(drm *drm, gbm *gbm)
 
 void CDRMLegacy::DestroyDrmLegacy()
 {
+  CGBMUtils::DestroySurface(m_gbm);
+  CGBMUtils::DestroyDevice(m_gbm);
   CDRMUtils::DestroyDrm();
-
-  if(m_gbm->surface)
-  {
-    gbm_surface_release_buffer(m_gbm->surface, m_gbm->bo);
-    m_gbm->bo = m_gbm->next_bo = nullptr;
-
-    gbm_surface_destroy(m_gbm->surface);
-    m_gbm->surface = nullptr;
-  }
-
-  if(m_gbm->dev)
-  {
-    gbm_device_destroy(m_gbm->dev);
-    m_gbm->dev = nullptr;
-  }
 }
diff --git a/xbmc/windowing/gbm/GBMUtils.cpp b/xbmc/windowing/gbm/GBMUtils.cpp
index 481959939435..053a22bfc676 100644
--- a/xbmc/windowing/gbm/GBMUtils.cpp
+++ b/xbmc/windowing/gbm/GBMUtils.cpp
@@ -21,18 +21,48 @@
 #include "GBMUtils.h"
 #include "utils/log.h"
 
-bool CGBMUtils::InitGbm(struct gbm *gbm, int hdisplay, int vdisplay)
+bool CGBMUtils::CreateDevice(struct gbm *gbm, int fd)
 {
-  gbm->width = hdisplay;
-  gbm->height = vdisplay;
+  if (gbm->device)
+    CLog::Log(LOGWARNING, "CGBMUtils::%s - device already created", __FUNCTION__);
 
-  gbm->surface = gbm_surface_create(gbm->dev,
+  gbm->device = gbm_create_device(fd);
+  if (!gbm->device)
+  {
+    CLog::Log(LOGERROR, "CGBMUtils::%s - failed to create device", __FUNCTION__);
+    return false;
+  }
+
+  return true;
+}
+
+void CGBMUtils::DestroyDevice(struct gbm *gbm)
+{
+  if (!gbm->device)
+    CLog::Log(LOGWARNING, "CGBMUtils::%s - device already destroyed", __FUNCTION__);
+
+  if (gbm->device)
+  {
+    gbm_device_destroy(gbm->device);
+    gbm->device = nullptr;
+  }
+}
+
+bool CGBMUtils::CreateSurface(struct gbm *gbm, int width, int height)
+{
+  if (gbm->surface)
+    CLog::Log(LOGWARNING, "CGBMUtils::%s - surface already created", __FUNCTION__);
+
+  gbm->width = width;
+  gbm->height = height;
+
+  gbm->surface = gbm_surface_create(gbm->device,
                                     gbm->width,
                                     gbm->height,
                                     GBM_FORMAT_ARGB8888,
                                     GBM_BO_USE_SCANOUT | GBM_BO_USE_RENDERING);
 
-  if(!gbm->surface)
+  if (!gbm->surface)
   {
     CLog::Log(LOGERROR, "CGBMUtils::%s - failed to create surface", __FUNCTION__);
     return false;
@@ -45,12 +75,14 @@ bool CGBMUtils::InitGbm(struct gbm *gbm, int hdisplay, int vdisplay)
   return true;
 }
 
-void CGBMUtils::DestroyGbm(struct gbm *gbm)
+void CGBMUtils::DestroySurface(struct gbm *gbm)
 {
-  if(gbm->surface)
+  if (!gbm->surface)
+    CLog::Log(LOGWARNING, "CGBMUtils::%s - surface already destroyed", __FUNCTION__);
+
+  if (gbm->surface)
   {
-    gbm_surface_release_buffer(gbm->surface, gbm->bo);
-    gbm->bo = gbm->next_bo = nullptr;
+    ReleaseBuffer(gbm);
 
     gbm_surface_destroy(gbm->surface);
     gbm->surface = nullptr;
@@ -58,3 +90,21 @@ void CGBMUtils::DestroyGbm(struct gbm *gbm)
     gbm->height = 0;
   }
 }
+
+struct gbm_bo *CGBMUtils::LockFrontBuffer(struct gbm *gbm)
+{
+  if (gbm->next_bo)
+    CLog::Log(LOGWARNING, "CGBMUtils::%s - uneven surface buffer usage", __FUNCTION__);
+
+  gbm->next_bo = gbm_surface_lock_front_buffer(gbm->surface);
+  return gbm->next_bo;
+}
+
+void CGBMUtils::ReleaseBuffer(struct gbm *gbm)
+{
+  if (gbm->bo)
+    gbm_surface_release_buffer(gbm->surface, gbm->bo);
+
+  gbm->bo = gbm->next_bo;
+  gbm->next_bo = nullptr;
+}
diff --git a/xbmc/windowing/gbm/GBMUtils.h b/xbmc/windowing/gbm/GBMUtils.h
index 287a2bb7e2eb..a8ae2fe5151e 100644
--- a/xbmc/windowing/gbm/GBMUtils.h
+++ b/xbmc/windowing/gbm/GBMUtils.h
@@ -24,7 +24,7 @@
 
 struct gbm
 {
-  struct gbm_device *dev = nullptr;
+  struct gbm_device *device = nullptr;
   struct gbm_surface *surface = nullptr;
   struct gbm_bo *bo = nullptr;
   struct gbm_bo *next_bo = nullptr;
@@ -35,6 +35,10 @@ struct gbm
 class CGBMUtils
 {
 public:
-  static bool InitGbm(struct gbm *gbm, int hdisplay, int vdisplay);
-  static void DestroyGbm(struct gbm *gbm);
+  static bool CreateDevice(struct gbm *gbm, int fd);
+  static void DestroyDevice(struct gbm *gbm);
+  static bool CreateSurface(struct gbm *gbm, int width, int height);
+  static void DestroySurface(struct gbm *gbm);
+  static struct gbm_bo *LockFrontBuffer(struct gbm *gbm);
+  static void ReleaseBuffer(struct gbm *gbm);
 };
diff --git a/xbmc/windowing/gbm/WinSystemGbm.cpp b/xbmc/windowing/gbm/WinSystemGbm.cpp
index b3daea656983..f15099cc3f2a 100644
--- a/xbmc/windowing/gbm/WinSystemGbm.cpp
+++ b/xbmc/windowing/gbm/WinSystemGbm.cpp
@@ -46,7 +46,7 @@ bool CWinSystemGbm::InitWindowSystem()
     return false;
   }
 
-  m_nativeDisplay = m_gbm.dev;
+  m_nativeDisplay = m_gbm.device;
 
   CLog::Log(LOGDEBUG, "CWinSystemGbm::%s - initialized DRM", __FUNCTION__);
   return CWinSystemBase::InitWindowSystem();
@@ -71,7 +71,7 @@ bool CWinSystemGbm::CreateNewWindow(const std::string& name,
     return false;
   }
 
-  if(!CGBMUtils::InitGbm(&m_gbm, m_drm.mode->hdisplay, m_drm.mode->vdisplay))
+  if(!CGBMUtils::CreateSurface(&m_gbm, m_drm.mode->hdisplay, m_drm.mode->vdisplay))
   {
     CLog::Log(LOGERROR, "CWinSystemGbm::%s - failed to initialize GBM", __FUNCTION__);
     return false;
@@ -85,7 +85,7 @@ bool CWinSystemGbm::CreateNewWindow(const std::string& name,
 
 bool CWinSystemGbm::DestroyWindow()
 {
-  CGBMUtils::DestroyGbm(&m_gbm);
+  CGBMUtils::DestroySurface(&m_gbm);
   m_nativeWindow = nullptr;
 
   CLog::Log(LOGDEBUG, "CWinSystemGbm::%s - deinitialized GBM", __FUNCTION__);

From 95b4e9e1a51a4fc3b2dc9e4de0b0abc40a14be0d Mon Sep 17 00:00:00 2001
From: Lukas Rusak <lorusak@gmail.com>
Date: Mon, 4 Dec 2017 18:30:41 -0800
Subject: [PATCH 2/3] windowing/gbm: move to OO structure

---
 xbmc/windowing/gbm/CMakeLists.txt              |   7 +-
 xbmc/windowing/gbm/DRM.cpp                     |  50 -----
 xbmc/windowing/gbm/DRM.h                       |  34 ----
 xbmc/windowing/gbm/DRMLegacy.cpp               | 107 +++++------
 xbmc/windowing/gbm/DRMLegacy.h                 |  13 +-
 xbmc/windowing/gbm/DRMUtils.cpp                | 249 ++++++++++++-------------
 xbmc/windowing/gbm/DRMUtils.h                  |  62 +++---
 xbmc/windowing/gbm/GBMUtils.cpp                |  73 ++++----
 xbmc/windowing/gbm/GBMUtils.h                  |  31 ++-
 xbmc/windowing/gbm/WinSystemGbm.cpp            |  55 ++++--
 xbmc/windowing/gbm/WinSystemGbm.h              |   9 +-
 xbmc/windowing/gbm/WinSystemGbmGLESContext.cpp |   4 +-
 12 files changed, 299 insertions(+), 395 deletions(-)
 delete mode 100644 xbmc/windowing/gbm/DRM.cpp
 delete mode 100644 xbmc/windowing/gbm/DRM.h

diff --git a/xbmc/windowing/gbm/CMakeLists.txt b/xbmc/windowing/gbm/CMakeLists.txt
index 65046b1c5d4b..95b4bf9ce782 100644
--- a/xbmc/windowing/gbm/CMakeLists.txt
+++ b/xbmc/windowing/gbm/CMakeLists.txt
@@ -2,15 +2,14 @@ set(SOURCES GLContextEGL.cpp
             WinSystemGbm.cpp
             GBMUtils.cpp
             DRMUtils.cpp
-            DRMLegacy.cpp
-            DRM.cpp)
+            DRMLegacy.cpp)
+
 
 set(HEADERS GLContextEGL.h
             WinSystemGbm.h
             GBMUtils.h
             DRMUtils.h
-            DRMLegacy.h
-            DRM.h)
+            DRMLegacy.h)
 
 if(OPENGLES_FOUND)
   list(APPEND SOURCES WinSystemGbmGLESContext.cpp)
diff --git a/xbmc/windowing/gbm/DRM.cpp b/xbmc/windowing/gbm/DRM.cpp
deleted file mode 100644
index de45f1414b00..000000000000
--- a/xbmc/windowing/gbm/DRM.cpp
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include "utils/log.h"
-
-#include "DRM.h"
-#include "DRMLegacy.h"
-
-void CDRM::FlipPage()
-{
-  CDRMLegacy::FlipPage();
-}
-
-bool CDRM::SetVideoMode(RESOLUTION_INFO res)
-{
-  return CDRMLegacy::SetVideoMode(res);
-}
-
-bool CDRM::InitDrm(drm *drm, gbm *gbm)
-{
-  if (CDRMLegacy::InitDrmLegacy(drm, gbm))
-  {
-    CLog::Log(LOGNOTICE, "CDRM::%s - initialized Legacy DRM", __FUNCTION__);
-    return true;
-  }
-
-  return false;
-}
-
-void CDRM::DestroyDrm()
-{
-  CDRMLegacy::DestroyDrmLegacy();
-}
diff --git a/xbmc/windowing/gbm/DRM.h b/xbmc/windowing/gbm/DRM.h
deleted file mode 100644
index 9c027ecaf00e..000000000000
--- a/xbmc/windowing/gbm/DRM.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#pragma once
-
-#include "DRMUtils.h"
-#include "GLContextEGL.h"
-
-class CDRM
-{
-public:
-  ~CDRM() = default;
-  void FlipPage();
-  bool SetVideoMode(RESOLUTION_INFO res);
-  bool InitDrm(drm *drm, gbm *gbm);
-  void DestroyDrm();
-};
diff --git a/xbmc/windowing/gbm/DRMLegacy.cpp b/xbmc/windowing/gbm/DRMLegacy.cpp
index 046db31ccbe5..dbf60f42f496 100644
--- a/xbmc/windowing/gbm/DRMLegacy.cpp
+++ b/xbmc/windowing/gbm/DRMLegacy.cpp
@@ -36,49 +36,40 @@
 
 #include "DRMLegacy.h"
 
-static struct drm *m_drm = nullptr;
-static struct gbm *m_gbm = nullptr;
-
 static int flip_happening = 0;
 
-static struct pollfd m_drm_fds;
-static drmEventContext m_drm_evctx;
-
-bool CDRMLegacy::SetVideoMode(RESOLUTION_INFO res)
+bool CDRMLegacy::SetVideoMode(RESOLUTION_INFO res, struct gbm_bo *bo)
 {
-  struct gbm_bo *bo = CGBMUtils::LockFrontBuffer(m_gbm);
-  struct drm_fb *drm_fb = CDRMUtils::DrmFbGetFromBo(bo);
+  struct drm_fb *drm_fb = DrmFbGetFromBo(bo);
 
-  auto ret = drmModeSetCrtc(m_drm->fd,
-                            m_drm->crtc->crtc->crtc_id,
+  auto ret = drmModeSetCrtc(m_fd,
+                            m_crtc->crtc->crtc_id,
                             drm_fb->fb_id,
                             0,
                             0,
-                            &m_drm->connector->connector->connector_id,
+                            &m_connector->connector->connector_id,
                             1,
-                            m_drm->mode);
+                            m_mode);
 
   if(ret < 0)
   {
     CLog::Log(LOGERROR,
-              "CDRMUtils::%s - failed to set crtc mode: %dx%d%s @ %d Hz",
+              "CDRMLegacy::%s - failed to set crtc mode: %dx%d%s @ %d Hz",
               __FUNCTION__,
-              m_drm->mode->hdisplay,
-              m_drm->mode->vdisplay,
-              m_drm->mode->flags & DRM_MODE_FLAG_INTERLACE ? "i" : "",
-              m_drm->mode->vrefresh);
+              m_mode->hdisplay,
+              m_mode->vdisplay,
+              m_mode->flags & DRM_MODE_FLAG_INTERLACE ? "i" : "",
+              m_mode->vrefresh);
 
     return false;
   }
 
-  CLog::Log(LOGDEBUG, "CDRMUtils::%s - set crtc mode: %dx%d%s @ %d Hz",
+  CLog::Log(LOGDEBUG, "CDRMLegacy::%s - set crtc mode: %dx%d%s @ %d Hz",
             __FUNCTION__,
-            m_drm->mode->hdisplay,
-            m_drm->mode->vdisplay,
-            m_drm->mode->flags & DRM_MODE_FLAG_INTERLACE ? "i" : "",
-            m_drm->mode->vrefresh);
-
-  CGBMUtils::ReleaseBuffer(m_gbm);
+            m_mode->hdisplay,
+            m_mode->vdisplay,
+            m_mode->flags & DRM_MODE_FLAG_INTERLACE ? "i" : "",
+            m_mode->vrefresh);
 
   return true;
 }
@@ -99,44 +90,50 @@ bool CDRMLegacy::WaitingForFlip()
     return false;
   }
 
-  m_drm_fds.fd = m_drm->fd;
-  m_drm_fds.events = POLLIN;
-
-  m_drm_evctx.version = DRM_EVENT_CONTEXT_VERSION;
-  m_drm_evctx.page_flip_handler = PageFlipHandler;
+  struct pollfd drm_fds =
+  {
+    m_fd,
+    POLLIN,
+    0,
+  };
 
-  m_drm_fds.revents = 0;
+  drmEventContext drm_evctx =
+  {
+    DRM_EVENT_CONTEXT_VERSION,
+    nullptr,
+    PageFlipHandler,
+    nullptr,
+  };
 
   while(flip_happening)
   {
-    auto ret = poll(&m_drm_fds, 1, -1);
+    auto ret = poll(&drm_fds, 1, -1);
 
     if(ret < 0)
     {
       return true;
     }
 
-    if(m_drm_fds.revents & (POLLHUP | POLLERR))
+    if(drm_fds.revents & (POLLHUP | POLLERR))
     {
       return true;
     }
 
-    if(m_drm_fds.revents & POLLIN)
+    if(drm_fds.revents & POLLIN)
     {
-      drmHandleEvent(m_drm->fd, &m_drm_evctx);
+      drmHandleEvent(m_fd, &drm_evctx);
     }
   }
 
   return false;
 }
 
-bool CDRMLegacy::QueueFlip()
+bool CDRMLegacy::QueueFlip(struct gbm_bo *bo)
 {
-  struct gbm_bo *bo = CGBMUtils::LockFrontBuffer(m_gbm);
-  struct drm_fb *drm_fb = CDRMUtils::DrmFbGetFromBo(bo);
+  struct drm_fb *drm_fb = DrmFbGetFromBo(bo);
 
-  auto ret = drmModePageFlip(m_drm->fd,
-                             m_drm->crtc->crtc->crtc_id,
+  auto ret = drmModePageFlip(m_fd,
+                             m_crtc->crtc->crtc_id,
                              drm_fb->fb_id,
                              DRM_MODE_PAGE_FLIP_EVENT,
                              &flip_happening);
@@ -150,39 +147,19 @@ bool CDRMLegacy::QueueFlip()
   return true;
 }
 
-void CDRMLegacy::FlipPage()
+void CDRMLegacy::FlipPage(struct gbm_bo *bo)
 {
-  flip_happening = QueueFlip();
+  flip_happening = QueueFlip(bo);
   WaitingForFlip();
-  CGBMUtils::ReleaseBuffer(m_gbm);
 }
 
-bool CDRMLegacy::InitDrmLegacy(drm *drm, gbm *gbm)
+bool CDRMLegacy::InitDrm()
 {
-  m_drm = drm;
-  m_gbm = gbm;
-
-  if (!CDRMUtils::InitDrm(m_drm))
-  {
-    return false;
-  }
-
-  if (!CGBMUtils::CreateDevice(m_gbm, m_drm->fd))
-  {
-    return false;
-  }
-
-  if (!CGBMUtils::CreateSurface(m_gbm, m_drm->mode->hdisplay, m_drm->mode->vdisplay))
+  if (!CDRMUtils::InitDrm())
   {
     return false;
   }
 
+  CLog::Log(LOGDEBUG, "CDRMLegacy::%s - initialized legacy DRM", __FUNCTION__);
   return true;
 }
-
-void CDRMLegacy::DestroyDrmLegacy()
-{
-  CGBMUtils::DestroySurface(m_gbm);
-  CGBMUtils::DestroyDevice(m_gbm);
-  CDRMUtils::DestroyDrm();
-}
diff --git a/xbmc/windowing/gbm/DRMLegacy.h b/xbmc/windowing/gbm/DRMLegacy.h
index 9dfa0bb9456a..edc589775083 100644
--- a/xbmc/windowing/gbm/DRMLegacy.h
+++ b/xbmc/windowing/gbm/DRMLegacy.h
@@ -26,14 +26,15 @@
 class CDRMLegacy : public CDRMUtils
 {
 public:
-  static void FlipPage();
-  static bool SetVideoMode(RESOLUTION_INFO res);
-  static bool InitDrmLegacy(drm *drm, gbm *gbm);
-  static void DestroyDrmLegacy();
+  CDRMLegacy() = default;
+  ~CDRMLegacy() { DestroyDrm(); };
+  virtual void FlipPage(struct gbm_bo *bo) override;
+  virtual bool SetVideoMode(RESOLUTION_INFO res, struct gbm_bo *bo) override;
+  virtual bool InitDrm() override;
 
 private:
-  static bool WaitingForFlip();
-  static bool QueueFlip();
+  bool WaitingForFlip();
+  bool QueueFlip(struct gbm_bo *bo);
   static void PageFlipHandler(int fd, unsigned int frame, unsigned int sec,
                               unsigned int usec, void *data);
 };
diff --git a/xbmc/windowing/gbm/DRMUtils.cpp b/xbmc/windowing/gbm/DRMUtils.cpp
index 6a173baa5af6..34ee89787b0b 100644
--- a/xbmc/windowing/gbm/DRMUtils.cpp
+++ b/xbmc/windowing/gbm/DRMUtils.cpp
@@ -35,14 +35,13 @@
 
 #include "DRMUtils.h"
 
-static struct drm *m_drm = nullptr;
-
-static drmModeResPtr m_drm_resources = nullptr;
-static drmModeCrtcPtr m_orig_crtc = nullptr;
-
-struct drm *CDRMUtils::GetDrm()
+CDRMUtils::CDRMUtils()
+  : m_connector(new connector)
+  , m_encoder(new encoder)
+  , m_crtc(new crtc)
+  , m_primary_plane(new plane)
+  , m_overlay_plane(new plane)
 {
-  return m_drm;
 }
 
 void CDRMUtils::WaitVBlank()
@@ -50,30 +49,31 @@ void CDRMUtils::WaitVBlank()
   drmVBlank vbl;
   vbl.request.type = DRM_VBLANK_RELATIVE;
   vbl.request.sequence = 1;
-  drmWaitVBlank(m_drm->fd, &vbl);
+  drmWaitVBlank(m_fd, &vbl);
 }
 
 bool CDRMUtils::SetMode(RESOLUTION_INFO res)
 {
-  m_drm->mode = &m_drm->connector->connector->modes[atoi(res.strId.c_str())];
+  m_mode = &m_connector->connector->modes[atoi(res.strId.c_str())];
 
   CLog::Log(LOGDEBUG, "CDRMUtils::%s - found crtc mode: %dx%d%s @ %d Hz",
             __FUNCTION__,
-            m_drm->mode->hdisplay,
-            m_drm->mode->vdisplay,
-            m_drm->mode->flags & DRM_MODE_FLAG_INTERLACE ? "i" : "",
-            m_drm->mode->vrefresh);
+            m_mode->hdisplay,
+            m_mode->vdisplay,
+            m_mode->flags & DRM_MODE_FLAG_INTERLACE ? "i" : "",
+            m_mode->vrefresh);
 
   return true;
 }
 
 void CDRMUtils::DrmFbDestroyCallback(struct gbm_bo *bo, void *data)
 {
+  int drm_fd = gbm_device_get_fd(gbm_bo_get_device(bo));
   struct drm_fb *fb = static_cast<drm_fb *>(data);
 
   if(fb->fb_id)
   {
-    drmModeRmFB(m_drm->fd, fb->fb_id);
+    drmModeRmFB(drm_fd, fb->fb_id);
   }
 
   delete (fb);
@@ -105,10 +105,10 @@ drm_fb * CDRMUtils::DrmFbGetFromBo(struct gbm_bo *bo)
   strides[0] = gbm_bo_get_stride(bo);
   memset(offsets, 0, 16);
 
-  auto ret = drmModeAddFB2(m_drm->fd,
+  auto ret = drmModeAddFB2(m_fd,
                            width,
                            height,
-                           m_drm->primary_plane->format,
+                           m_primary_plane->format,
                            handles,
                            strides,
                            offsets,
@@ -129,7 +129,7 @@ drm_fb * CDRMUtils::DrmFbGetFromBo(struct gbm_bo *bo)
 
 bool CDRMUtils::GetResources()
 {
-  m_drm_resources = drmModeGetResources(m_drm->fd);
+  m_drm_resources = drmModeGetResources(m_fd);
   if(!m_drm_resources)
   {
     return false;
@@ -142,35 +142,35 @@ bool CDRMUtils::GetConnector()
 {
   for(auto i = 0; i < m_drm_resources->count_connectors; i++)
   {
-    m_drm->connector->connector = drmModeGetConnector(m_drm->fd,
+    m_connector->connector = drmModeGetConnector(m_fd,
                                                       m_drm_resources->connectors[i]);
-    if(m_drm->connector->connector->connection == DRM_MODE_CONNECTED)
+    if(m_connector->connector->connection == DRM_MODE_CONNECTED)
     {
       CLog::Log(LOGDEBUG, "CDRMUtils::%s - found connector: %d", __FUNCTION__,
-                                                                 m_drm->connector->connector->connector_id);
+                                                                 m_connector->connector->connector_id);
       break;
     }
-    drmModeFreeConnector(m_drm->connector->connector);
-    m_drm->connector->connector = nullptr;
+    drmModeFreeConnector(m_connector->connector);
+    m_connector->connector = nullptr;
   }
 
-  if(!m_drm->connector->connector)
+  if(!m_connector->connector)
   {
     CLog::Log(LOGERROR, "CDRMUtils::%s - could not get connector: %s", __FUNCTION__, strerror(errno));
     return false;
   }
 
-  m_drm->connector->props = drmModeObjectGetProperties(m_drm->fd, m_drm->connector->connector->connector_id, DRM_MODE_OBJECT_CONNECTOR);
-  if (!m_drm->connector->props)
+  m_connector->props = drmModeObjectGetProperties(m_fd, m_connector->connector->connector_id, DRM_MODE_OBJECT_CONNECTOR);
+  if (!m_connector->props)
   {
-    CLog::Log(LOGERROR, "CDRMUtils::%s - could not get connector %u properties: %s", __FUNCTION__, m_drm->connector->connector->connector_id, strerror(errno));
+    CLog::Log(LOGERROR, "CDRMUtils::%s - could not get connector %u properties: %s", __FUNCTION__, m_connector->connector->connector_id, strerror(errno));
     return false;
   }
 
-  m_drm->connector->props_info = new drmModePropertyPtr;
-  for (uint32_t i = 0; i < m_drm->connector->props->count_props; i++)
+  m_connector->props_info = new drmModePropertyPtr;
+  for (uint32_t i = 0; i < m_connector->props->count_props; i++)
   {
-    m_drm->connector->props_info[i] = drmModeGetProperty(m_drm->fd, m_drm->connector->props->props[i]);
+    m_connector->props_info[i] = drmModeGetProperty(m_fd, m_connector->props->props[i]);
   }
 
   return true;
@@ -180,18 +180,18 @@ bool CDRMUtils::GetEncoder()
 {
   for(auto i = 0; i < m_drm_resources->count_encoders; i++)
   {
-    m_drm->encoder->encoder = drmModeGetEncoder(m_drm->fd, m_drm_resources->encoders[i]);
-    if(m_drm->encoder->encoder->encoder_id == m_drm->connector->connector->encoder_id)
+    m_encoder->encoder = drmModeGetEncoder(m_fd, m_drm_resources->encoders[i]);
+    if(m_encoder->encoder->encoder_id == m_connector->connector->encoder_id)
     {
       CLog::Log(LOGDEBUG, "CDRMUtils::%s - found encoder: %d", __FUNCTION__,
-                                                               m_drm->encoder->encoder->encoder_id);
+                                                               m_encoder->encoder->encoder_id);
       break;
     }
-    drmModeFreeEncoder(m_drm->encoder->encoder);
-    m_drm->encoder->encoder = nullptr;
+    drmModeFreeEncoder(m_encoder->encoder);
+    m_encoder->encoder = nullptr;
   }
 
-  if(!m_drm->encoder->encoder)
+  if(!m_encoder->encoder)
   {
     CLog::Log(LOGERROR, "CDRMUtils::%s - could not get encoder: %s", __FUNCTION__, strerror(errno));
     return false;
@@ -204,35 +204,35 @@ bool CDRMUtils::GetCrtc()
 {
   for(auto i = 0; i < m_drm_resources->count_crtcs; i++)
   {
-    m_drm->crtc->crtc = drmModeGetCrtc(m_drm->fd, m_drm_resources->crtcs[i]);
-    if(m_drm->crtc->crtc->crtc_id == m_drm->encoder->encoder->crtc_id)
+    m_crtc->crtc = drmModeGetCrtc(m_fd, m_drm_resources->crtcs[i]);
+    if(m_crtc->crtc->crtc_id == m_encoder->encoder->crtc_id)
     {
       CLog::Log(LOGDEBUG, "CDRMUtils::%s - found crtc: %d", __FUNCTION__,
-                                                            m_drm->crtc->crtc->crtc_id);
-      m_drm->crtc_index = i;
+                                                            m_crtc->crtc->crtc_id);
+      m_crtc_index = i;
       break;
     }
-    drmModeFreeCrtc(m_drm->crtc->crtc);
-    m_drm->crtc->crtc = nullptr;
+    drmModeFreeCrtc(m_crtc->crtc);
+    m_crtc->crtc = nullptr;
   }
 
-  if(!m_drm->crtc->crtc)
+  if(!m_crtc->crtc)
   {
     CLog::Log(LOGERROR, "CDRMUtils::%s - could not get crtc: %s", __FUNCTION__, strerror(errno));
     return false;
   }
 
-  m_drm->crtc->props = drmModeObjectGetProperties(m_drm->fd, m_drm->crtc->crtc->crtc_id, DRM_MODE_OBJECT_CRTC);
-  if (!m_drm->crtc->props)
+  m_crtc->props = drmModeObjectGetProperties(m_fd, m_crtc->crtc->crtc_id, DRM_MODE_OBJECT_CRTC);
+  if (!m_crtc->props)
   {
-    CLog::Log(LOGERROR, "CDRMUtils::%s - could not get crtc %u properties: %s", __FUNCTION__, m_drm->crtc->crtc->crtc_id, strerror(errno));
+    CLog::Log(LOGERROR, "CDRMUtils::%s - could not get crtc %u properties: %s", __FUNCTION__, m_crtc->crtc->crtc_id, strerror(errno));
     return false;
   }
 
-  m_drm->crtc->props_info = new drmModePropertyPtr;
-  for (uint32_t i = 0; i < m_drm->crtc->props->count_props; i++)
+  m_crtc->props_info = new drmModePropertyPtr;
+  for (uint32_t i = 0; i < m_crtc->props->count_props; i++)
   {
-    m_drm->crtc->props_info[i] = drmModeGetProperty(m_drm->fd, m_drm->crtc->props->props[i]);
+    m_crtc->props_info[i] = drmModeGetProperty(m_fd, m_crtc->props->props[i]);
   }
 
   return true;
@@ -240,32 +240,32 @@ bool CDRMUtils::GetCrtc()
 
 bool CDRMUtils::GetPreferredMode()
 {
-  for(auto i = 0, area = 0; i < m_drm->connector->connector->count_modes; i++)
+  for(auto i = 0, area = 0; i < m_connector->connector->count_modes; i++)
   {
-    drmModeModeInfo *current_mode = &m_drm->connector->connector->modes[i];
+    drmModeModeInfo *current_mode = &m_connector->connector->modes[i];
 
     if(current_mode->type & DRM_MODE_TYPE_PREFERRED)
     {
-      m_drm->mode = current_mode;
+      m_mode = current_mode;
       CLog::Log(LOGDEBUG,
                 "CDRMUtils::%s - found preferred mode: %dx%d%s @ %d Hz",
                 __FUNCTION__,
-                m_drm->mode->hdisplay,
-                m_drm->mode->vdisplay,
-                m_drm->mode->flags & DRM_MODE_FLAG_INTERLACE ? "i" : "",
-                m_drm->mode->vrefresh);
+                m_mode->hdisplay,
+                m_mode->vdisplay,
+                m_mode->flags & DRM_MODE_FLAG_INTERLACE ? "i" : "",
+                m_mode->vrefresh);
       break;
     }
 
     auto current_area = current_mode->hdisplay * current_mode->vdisplay;
     if (current_area > area)
     {
-      m_drm->mode = current_mode;
+      m_mode = current_mode;
       area = current_area;
     }
   }
 
-  if(!m_drm->mode)
+  if(!m_mode)
   {
     CLog::Log(LOGDEBUG, "CDRMUtils::%s - failed to find preferred mode", __FUNCTION__);
     return false;
@@ -281,7 +281,7 @@ bool CDRMUtils::GetPlanes()
   uint32_t overlay_plane_id = -1;
   uint32_t fourcc = 0;
 
-  plane_resources = drmModeGetPlaneResources(m_drm->fd);
+  plane_resources = drmModeGetPlaneResources(m_fd);
   if (!plane_resources)
   {
     CLog::Log(LOGERROR, "CDRMUtils::%s - drmModeGetPlaneResources failed: %s", __FUNCTION__, strerror(errno));
@@ -291,20 +291,20 @@ bool CDRMUtils::GetPlanes()
   for (uint32_t i = 0; i < plane_resources->count_planes; i++)
   {
     uint32_t id = plane_resources->planes[i];
-    drmModePlanePtr plane = drmModeGetPlane(m_drm->fd, id);
+    drmModePlanePtr plane = drmModeGetPlane(m_fd, id);
     if (!plane)
     {
       CLog::Log(LOGERROR, "CDRMUtils::%s - drmModeGetPlane(%u) failed: %s", __FUNCTION__, id, strerror(errno));
       continue;
     }
 
-    if (plane->possible_crtcs & (1 << m_drm->crtc_index))
+    if (plane->possible_crtcs & (1 << m_crtc_index))
     {
-      drmModeObjectPropertiesPtr props = drmModeObjectGetProperties(m_drm->fd, id, DRM_MODE_OBJECT_PLANE);
+      drmModeObjectPropertiesPtr props = drmModeObjectGetProperties(m_fd, id, DRM_MODE_OBJECT_PLANE);
 
       for (uint32_t j = 0; j < props->count_props; j++)
       {
-        drmModePropertyPtr p = drmModeGetProperty(m_drm->fd, props->props[j]);
+        drmModePropertyPtr p = drmModeGetProperty(m_fd, props->props[j]);
 
         if ((strcmp(p->name, "type") == 0) && (props->prop_values[j] == DRM_PLANE_TYPE_PRIMARY))
         {
@@ -329,38 +329,38 @@ bool CDRMUtils::GetPlanes()
   drmModeFreePlaneResources(plane_resources);
 
   // primary plane
-  m_drm->primary_plane->plane = drmModeGetPlane(m_drm->fd, primary_plane_id);
-  if (!m_drm->primary_plane->plane)
+  m_primary_plane->plane = drmModeGetPlane(m_fd, primary_plane_id);
+  if (!m_primary_plane->plane)
   {
     CLog::Log(LOGERROR, "CDRMUtils::%s - could not get primary plane %i: %s", __FUNCTION__, primary_plane_id, strerror(errno));
     return false;
   }
 
-  m_drm->primary_plane->props = drmModeObjectGetProperties(m_drm->fd, primary_plane_id, DRM_MODE_OBJECT_PLANE);
-  if (!m_drm->primary_plane->props)
+  m_primary_plane->props = drmModeObjectGetProperties(m_fd, primary_plane_id, DRM_MODE_OBJECT_PLANE);
+  if (!m_primary_plane->props)
   {
     CLog::Log(LOGERROR, "CDRMUtils::%s - could not get primary plane %u properties: %s", __FUNCTION__, primary_plane_id, strerror(errno));
     return false;
   }
 
-  m_drm->primary_plane->props_info = new drmModePropertyPtr;
-  for (uint32_t i = 0; i < m_drm->primary_plane->props->count_props; i++)
+  m_primary_plane->props_info = new drmModePropertyPtr;
+  for (uint32_t i = 0; i < m_primary_plane->props->count_props; i++)
   {
-    m_drm->primary_plane->props_info[i] = drmModeGetProperty(m_drm->fd, m_drm->primary_plane->props->props[i]);
+    m_primary_plane->props_info[i] = drmModeGetProperty(m_fd, m_primary_plane->props->props[i]);
   }
 
-  for (uint32_t i = 0; i < m_drm->primary_plane->plane->count_formats; i++)
+  for (uint32_t i = 0; i < m_primary_plane->plane->count_formats; i++)
   {
     /* we want an alpha layer so break if we find one */
-    if (m_drm->primary_plane->plane->formats[i] == DRM_FORMAT_XRGB8888)
+    if (m_primary_plane->plane->formats[i] == DRM_FORMAT_XRGB8888)
     {
       fourcc = DRM_FORMAT_XRGB8888;
-      m_drm->primary_plane->format = fourcc;
+      m_primary_plane->format = fourcc;
     }
-    else if (m_drm->primary_plane->plane->formats[i] == DRM_FORMAT_ARGB8888)
+    else if (m_primary_plane->plane->formats[i] == DRM_FORMAT_ARGB8888)
     {
       fourcc = DRM_FORMAT_ARGB8888;
-      m_drm->primary_plane->format = fourcc;
+      m_primary_plane->format = fourcc;
       break;
     }
   }
@@ -374,40 +374,40 @@ bool CDRMUtils::GetPlanes()
   CLog::Log(LOGDEBUG, "CDRMUtils::%s - primary plane format: %c%c%c%c", __FUNCTION__, fourcc, fourcc >> 8, fourcc >> 16, fourcc >> 24);
 
   // overlay plane
-  m_drm->overlay_plane->plane = drmModeGetPlane(m_drm->fd, overlay_plane_id);
-  if (!m_drm->overlay_plane->plane)
+  m_overlay_plane->plane = drmModeGetPlane(m_fd, overlay_plane_id);
+  if (!m_overlay_plane->plane)
   {
     CLog::Log(LOGERROR, "CDRMUtils::%s - could not get overlay plane %i: %s", __FUNCTION__, overlay_plane_id, strerror(errno));
     return false;
   }
 
-  m_drm->overlay_plane->props = drmModeObjectGetProperties(m_drm->fd, overlay_plane_id, DRM_MODE_OBJECT_PLANE);
-  if (!m_drm->overlay_plane->props)
+  m_overlay_plane->props = drmModeObjectGetProperties(m_fd, overlay_plane_id, DRM_MODE_OBJECT_PLANE);
+  if (!m_overlay_plane->props)
   {
     CLog::Log(LOGERROR, "CDRMUtils::%s - could not get overlay plane %u properties: %s", __FUNCTION__, overlay_plane_id, strerror(errno));
     return false;
   }
 
-  m_drm->overlay_plane->props_info = new drmModePropertyPtr;
-  for (uint32_t i = 0; i < m_drm->overlay_plane->props->count_props; i++)
+  m_overlay_plane->props_info = new drmModePropertyPtr;
+  for (uint32_t i = 0; i < m_overlay_plane->props->count_props; i++)
   {
-    m_drm->overlay_plane->props_info[i] = drmModeGetProperty(m_drm->fd, m_drm->overlay_plane->props->props[i]);
+    m_overlay_plane->props_info[i] = drmModeGetProperty(m_fd, m_overlay_plane->props->props[i]);
   }
 
   fourcc = 0;
 
-  for (uint32_t i = 0; i < m_drm->overlay_plane->plane->count_formats; i++)
+  for (uint32_t i = 0; i < m_overlay_plane->plane->count_formats; i++)
   {
     /* we want an alpha layer so break if we find one */
-    if (m_drm->overlay_plane->plane->formats[i] == DRM_FORMAT_XRGB8888)
+    if (m_overlay_plane->plane->formats[i] == DRM_FORMAT_XRGB8888)
     {
       fourcc = DRM_FORMAT_XRGB8888;
-      m_drm->overlay_plane->format = fourcc;
+      m_overlay_plane->format = fourcc;
     }
-    else if(m_drm->overlay_plane->plane->formats[i] == DRM_FORMAT_ARGB8888)
+    else if(m_overlay_plane->plane->formats[i] == DRM_FORMAT_ARGB8888)
     {
       fourcc = DRM_FORMAT_ARGB8888;
-      m_drm->overlay_plane->format = fourcc;
+      m_overlay_plane->format = fourcc;
       break;
     }
   }
@@ -455,28 +455,20 @@ int CDRMUtils::Open(const char* device)
   return fd;
 }
 
-bool CDRMUtils::InitDrm(drm *drm)
+bool CDRMUtils::InitDrm()
 {
-  m_drm = drm;
-
-  m_drm->connector = new connector;
-  m_drm->encoder = new encoder;
-  m_drm->crtc = new crtc;
-  m_drm->primary_plane = new plane;
-  m_drm->overlay_plane = new plane;
-
   for(int i = 0; i < 10; ++i)
   {
-    if (m_drm->fd >= 0)
+    if (m_fd >= 0)
     {
-      drmClose(m_drm->fd);
+      drmClose(m_fd);
     }
 
     std::string device = "/dev/dri/card";
     device.append(std::to_string(i));
-    m_drm->fd = CDRMUtils::Open(device.c_str());
+    m_fd = CDRMUtils::Open(device.c_str());
 
-    if(m_drm->fd >= 0)
+    if(m_fd >= 0)
     {
       if(!GetResources())
       {
@@ -498,7 +490,7 @@ bool CDRMUtils::InitDrm(drm *drm)
         continue;
       }
 
-      auto ret = drmSetClientCap(m_drm->fd, DRM_CLIENT_CAP_UNIVERSAL_PLANES, 1);
+      auto ret = drmSetClientCap(m_fd, DRM_CLIENT_CAP_UNIVERSAL_PLANES, 1);
       if (ret)
       {
         CLog::Log(LOGERROR, "CDRMUtils::%s - failed to set Universal planes capability: %s", __FUNCTION__, strerror(errno));
@@ -515,8 +507,9 @@ bool CDRMUtils::InitDrm(drm *drm)
   }
 
   drmModeFreeResources(m_drm_resources);
+  m_drm_resources = nullptr;
 
-  if(m_drm->fd < 0)
+  if(m_fd < 0)
   {
     return false;
   }
@@ -526,9 +519,9 @@ bool CDRMUtils::InitDrm(drm *drm)
     return false;
   }
 
-  drmSetMaster(m_drm->fd);
+  drmSetMaster(m_fd);
 
-  m_orig_crtc = drmModeGetCrtc(m_drm->fd, m_drm->crtc->crtc->crtc_id);
+  m_orig_crtc = drmModeGetCrtc(m_fd, m_crtc->crtc->crtc_id);
 
   return true;
 }
@@ -540,12 +533,12 @@ bool CDRMUtils::RestoreOriginalMode()
     return false;
   }
 
-  auto ret = drmModeSetCrtc(m_drm->fd,
+  auto ret = drmModeSetCrtc(m_fd,
                             m_orig_crtc->crtc_id,
                             m_orig_crtc->buffer_id,
                             m_orig_crtc->x,
                             m_orig_crtc->y,
-                            &m_drm->connector->connector->connector_id,
+                            &m_connector->connector->connector_id,
                             1,
                             &m_orig_crtc->mode);
 
@@ -570,54 +563,54 @@ void CDRMUtils::DestroyDrm()
   if (m_drm_resources)
   {
     drmModeFreeResources(m_drm_resources);
+    m_drm_resources = nullptr;
   }
 
-  drmDropMaster(m_drm->fd);
-  close(m_drm->fd);
-
-  m_drm_resources = nullptr;
+  drmDropMaster(m_fd);
+  close(m_fd);
 
-  m_drm->primary_plane = nullptr;
-  m_drm->overlay_plane = nullptr;
-  m_drm->connector = nullptr;
-  m_drm->crtc = nullptr;
-  m_drm->fd = -1;
-  m_drm->mode = nullptr;
+  m_connector = nullptr;
+  m_encoder = nullptr;
+  m_crtc = nullptr;
+  m_primary_plane = nullptr;
+  m_overlay_plane = nullptr;
+  m_fd = -1;
+  m_mode = nullptr;
 }
 
 bool CDRMUtils::GetModes(std::vector<RESOLUTION_INFO> &resolutions)
 {
-  for(auto i = 0; i < m_drm->connector->connector->count_modes; i++)
+  for(auto i = 0; i < m_connector->connector->count_modes; i++)
   {
     RESOLUTION_INFO res;
     res.iScreen = 0;
-    res.iWidth = m_drm->connector->connector->modes[i].hdisplay;
-    res.iHeight = m_drm->connector->connector->modes[i].vdisplay;
-    res.iScreenWidth = m_drm->connector->connector->modes[i].hdisplay;
-    res.iScreenHeight = m_drm->connector->connector->modes[i].vdisplay;
-    if (m_drm->connector->connector->modes[i].clock % 10 != 0)
-      res.fRefreshRate = (float)m_drm->connector->connector->modes[i].vrefresh * (1000.0f/1001.0f);
+    res.iWidth = m_connector->connector->modes[i].hdisplay;
+    res.iHeight = m_connector->connector->modes[i].vdisplay;
+    res.iScreenWidth = m_connector->connector->modes[i].hdisplay;
+    res.iScreenHeight = m_connector->connector->modes[i].vdisplay;
+    if (m_connector->connector->modes[i].clock % 10 != 0)
+      res.fRefreshRate = (float)m_connector->connector->modes[i].vrefresh * (1000.0f/1001.0f);
     else
-      res.fRefreshRate = m_drm->connector->connector->modes[i].vrefresh;
+      res.fRefreshRate = m_connector->connector->modes[i].vrefresh;
     res.iSubtitles = static_cast<int>(0.965 * res.iHeight);
     res.fPixelRatio = 1.0f;
     res.bFullScreen = true;
-    res.strMode = m_drm->connector->connector->modes[i].name;
+    res.strMode = m_connector->connector->modes[i].name;
     res.strId = std::to_string(i);
 
-    if(m_drm->connector->connector->modes[i].flags & DRM_MODE_FLAG_3D_MASK)
+    if(m_connector->connector->modes[i].flags & DRM_MODE_FLAG_3D_MASK)
     {
-      if(m_drm->connector->connector->modes[i].flags & DRM_MODE_FLAG_3D_TOP_AND_BOTTOM)
+      if(m_connector->connector->modes[i].flags & DRM_MODE_FLAG_3D_TOP_AND_BOTTOM)
       {
         res.dwFlags = D3DPRESENTFLAG_MODE3DTB;
       }
-      else if(m_drm->connector->connector->modes[i].flags
+      else if(m_connector->connector->modes[i].flags
           & DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF)
       {
         res.dwFlags = D3DPRESENTFLAG_MODE3DSBS;
       }
     }
-    else if(m_drm->connector->connector->modes[i].flags & DRM_MODE_FLAG_INTERLACE)
+    else if(m_connector->connector->modes[i].flags & DRM_MODE_FLAG_INTERLACE)
     {
       res.dwFlags = D3DPRESENTFLAG_INTERLACED;
     }
diff --git a/xbmc/windowing/gbm/DRMUtils.h b/xbmc/windowing/gbm/DRMUtils.h
index 6cc96e5ce856..ed6aaabffdb6 100644
--- a/xbmc/windowing/gbm/DRMUtils.h
+++ b/xbmc/windowing/gbm/DRMUtils.h
@@ -55,21 +55,6 @@ struct crtc
   drmModePropertyRes **props_info;
 };
 
-struct drm
-{
-  int fd;
-
-  struct plane *primary_plane;
-  struct plane *overlay_plane;
-  struct connector *connector;
-  struct encoder *encoder;
-  struct crtc *crtc;
-
-  drmModeModeInfo *mode;
-
-  int crtc_index;
-};
-
 struct drm_fb
 {
   struct gbm_bo *bo;
@@ -79,24 +64,41 @@ struct drm_fb
 class CDRMUtils
 {
 public:
-  static bool InitDrm(drm *drm);
-  static void DestroyDrm();
-  static bool GetModes(std::vector<RESOLUTION_INFO> &resolutions);
-  static bool SetMode(RESOLUTION_INFO res);
-  static void WaitVBlank();
-  static struct drm *GetDrm();
+  CDRMUtils();
+  virtual ~CDRMUtils() = default;
+  virtual void FlipPage(struct gbm_bo *bo) {};
+  virtual bool SetVideoMode(RESOLUTION_INFO res, struct gbm_bo *bo) { return false; };
+  virtual bool InitDrm();
+
+  void DestroyDrm();
+  bool GetModes(std::vector<RESOLUTION_INFO> &resolutions);
+  bool SetMode(RESOLUTION_INFO res);
+  void WaitVBlank();
+
+  int m_fd;
+
+  struct connector *m_connector = nullptr;
+  struct encoder *m_encoder = nullptr;
+  struct crtc *m_crtc = nullptr;
+  struct plane *m_primary_plane = nullptr;
+  struct plane *m_overlay_plane = nullptr;
+  drmModeModeInfo *m_mode = nullptr;
 
 protected:
-  static drm_fb * DrmFbGetFromBo(struct gbm_bo *bo);
+  drm_fb * DrmFbGetFromBo(struct gbm_bo *bo);
 
 private:
-  static bool GetResources();
-  static bool GetConnector();
-  static bool GetEncoder();
-  static bool GetCrtc();
-  static bool GetPlanes();
-  static bool GetPreferredMode();
-  static int Open(const char* device);
-  static bool RestoreOriginalMode();
+  bool GetResources();
+  bool GetConnector();
+  bool GetEncoder();
+  bool GetCrtc();
+  bool GetPlanes();
+  bool GetPreferredMode();
+  int Open(const char* device);
+  bool RestoreOriginalMode();
   static void DrmFbDestroyCallback(struct gbm_bo *bo, void *data);
+
+  int m_crtc_index;
+  drmModeResPtr m_drm_resources = nullptr;
+  drmModeCrtcPtr m_orig_crtc = nullptr;
 };
diff --git a/xbmc/windowing/gbm/GBMUtils.cpp b/xbmc/windowing/gbm/GBMUtils.cpp
index 053a22bfc676..e22167f914e2 100644
--- a/xbmc/windowing/gbm/GBMUtils.cpp
+++ b/xbmc/windowing/gbm/GBMUtils.cpp
@@ -21,13 +21,13 @@
 #include "GBMUtils.h"
 #include "utils/log.h"
 
-bool CGBMUtils::CreateDevice(struct gbm *gbm, int fd)
+bool CGBMUtils::CreateDevice(int fd)
 {
-  if (gbm->device)
+  if (m_device)
     CLog::Log(LOGWARNING, "CGBMUtils::%s - device already created", __FUNCTION__);
 
-  gbm->device = gbm_create_device(fd);
-  if (!gbm->device)
+  m_device = gbm_create_device(fd);
+  if (!m_device)
   {
     CLog::Log(LOGERROR, "CGBMUtils::%s - failed to create device", __FUNCTION__);
     return false;
@@ -36,75 +36,70 @@ bool CGBMUtils::CreateDevice(struct gbm *gbm, int fd)
   return true;
 }
 
-void CGBMUtils::DestroyDevice(struct gbm *gbm)
+void CGBMUtils::DestroyDevice()
 {
-  if (!gbm->device)
+  if (!m_device)
     CLog::Log(LOGWARNING, "CGBMUtils::%s - device already destroyed", __FUNCTION__);
 
-  if (gbm->device)
+  if (m_device)
   {
-    gbm_device_destroy(gbm->device);
-    gbm->device = nullptr;
+    gbm_device_destroy(m_device);
+    m_device = nullptr;
   }
 }
 
-bool CGBMUtils::CreateSurface(struct gbm *gbm, int width, int height)
+bool CGBMUtils::CreateSurface(int width, int height)
 {
-  if (gbm->surface)
+  if (m_surface)
     CLog::Log(LOGWARNING, "CGBMUtils::%s - surface already created", __FUNCTION__);
 
-  gbm->width = width;
-  gbm->height = height;
+  m_surface = gbm_surface_create(m_device,
+                                 width,
+                                 height,
+                                 GBM_FORMAT_ARGB8888,
+                                 GBM_BO_USE_SCANOUT | GBM_BO_USE_RENDERING);
 
-  gbm->surface = gbm_surface_create(gbm->device,
-                                    gbm->width,
-                                    gbm->height,
-                                    GBM_FORMAT_ARGB8888,
-                                    GBM_BO_USE_SCANOUT | GBM_BO_USE_RENDERING);
-
-  if (!gbm->surface)
+  if (!m_surface)
   {
     CLog::Log(LOGERROR, "CGBMUtils::%s - failed to create surface", __FUNCTION__);
     return false;
   }
 
   CLog::Log(LOGDEBUG, "CGBMUtils::%s - created surface with size %dx%d", __FUNCTION__,
-                                                                         gbm->width,
-                                                                         gbm->height);
+                                                                         width,
+                                                                         height);
 
   return true;
 }
 
-void CGBMUtils::DestroySurface(struct gbm *gbm)
+void CGBMUtils::DestroySurface()
 {
-  if (!gbm->surface)
+  if (!m_surface)
     CLog::Log(LOGWARNING, "CGBMUtils::%s - surface already destroyed", __FUNCTION__);
 
-  if (gbm->surface)
+  if (m_surface)
   {
-    ReleaseBuffer(gbm);
+    ReleaseBuffer();
 
-    gbm_surface_destroy(gbm->surface);
-    gbm->surface = nullptr;
-    gbm->width = 0;
-    gbm->height = 0;
+    gbm_surface_destroy(m_surface);
+    m_surface = nullptr;
   }
 }
 
-struct gbm_bo *CGBMUtils::LockFrontBuffer(struct gbm *gbm)
+struct gbm_bo *CGBMUtils::LockFrontBuffer()
 {
-  if (gbm->next_bo)
+  if (m_next_bo)
     CLog::Log(LOGWARNING, "CGBMUtils::%s - uneven surface buffer usage", __FUNCTION__);
 
-  gbm->next_bo = gbm_surface_lock_front_buffer(gbm->surface);
-  return gbm->next_bo;
+  m_next_bo = gbm_surface_lock_front_buffer(m_surface);
+  return m_next_bo;
 }
 
-void CGBMUtils::ReleaseBuffer(struct gbm *gbm)
+void CGBMUtils::ReleaseBuffer()
 {
-  if (gbm->bo)
-    gbm_surface_release_buffer(gbm->surface, gbm->bo);
+  if (m_bo)
+    gbm_surface_release_buffer(m_surface, m_bo);
 
-  gbm->bo = gbm->next_bo;
-  gbm->next_bo = nullptr;
+  m_bo = m_next_bo;
+  m_next_bo = nullptr;
 }
diff --git a/xbmc/windowing/gbm/GBMUtils.h b/xbmc/windowing/gbm/GBMUtils.h
index a8ae2fe5151e..19d3b99de741 100644
--- a/xbmc/windowing/gbm/GBMUtils.h
+++ b/xbmc/windowing/gbm/GBMUtils.h
@@ -22,23 +22,22 @@
 
 #include <gbm.h>
 
-struct gbm
-{
-  struct gbm_device *device = nullptr;
-  struct gbm_surface *surface = nullptr;
-  struct gbm_bo *bo = nullptr;
-  struct gbm_bo *next_bo = nullptr;
-  int width = 0;
-  int height = 0;
-};
-
 class CGBMUtils
 {
 public:
-  static bool CreateDevice(struct gbm *gbm, int fd);
-  static void DestroyDevice(struct gbm *gbm);
-  static bool CreateSurface(struct gbm *gbm, int width, int height);
-  static void DestroySurface(struct gbm *gbm);
-  static struct gbm_bo *LockFrontBuffer(struct gbm *gbm);
-  static void ReleaseBuffer(struct gbm *gbm);
+  CGBMUtils() = default;
+  ~CGBMUtils() = default;
+  bool CreateDevice(int fd);
+  void DestroyDevice();
+  bool CreateSurface(int width, int height);
+  void DestroySurface();
+  struct gbm_bo *LockFrontBuffer();
+  void ReleaseBuffer();
+
+  struct gbm_device *m_device = nullptr;
+  struct gbm_surface *m_surface = nullptr;
+
+protected:
+  struct gbm_bo *m_bo = nullptr;
+  struct gbm_bo *m_next_bo = nullptr;
 };
diff --git a/xbmc/windowing/gbm/WinSystemGbm.cpp b/xbmc/windowing/gbm/WinSystemGbm.cpp
index f15099cc3f2a..2651d80202c7 100644
--- a/xbmc/windowing/gbm/WinSystemGbm.cpp
+++ b/xbmc/windowing/gbm/WinSystemGbm.cpp
@@ -30,8 +30,11 @@
 #include "settings/DisplaySettings.h"
 #include "utils/log.h"
 #include "../WinEventsLinux.h"
+#include "DRMLegacy.h"
 
 CWinSystemGbm::CWinSystemGbm() :
+  m_DRM(new CDRMLegacy),
+  m_GBM(new CGBMUtils),
   m_nativeDisplay(nullptr),
   m_nativeWindow(nullptr)
 {
@@ -40,13 +43,20 @@ CWinSystemGbm::CWinSystemGbm() :
 
 bool CWinSystemGbm::InitWindowSystem()
 {
-  if (!m_DRM.InitDrm(&m_drm, &m_gbm))
+  if (!m_DRM->InitDrm())
   {
-    CLog::Log(LOGERROR, "CWinSystemGbm::%s - failed to initialize DRM", __FUNCTION__);
+    CLog::Log(LOGERROR, "CWinSystemGbm::%s - failed to initialize Legacy DRM", __FUNCTION__);
+    m_DRM.reset();
     return false;
   }
 
-  m_nativeDisplay = m_gbm.device;
+  if (!m_GBM->CreateDevice(m_DRM->m_fd))
+  {
+    m_GBM.reset();
+    return false;
+  }
+
+  m_nativeDisplay = m_GBM->m_device;
 
   CLog::Log(LOGDEBUG, "CWinSystemGbm::%s - initialized DRM", __FUNCTION__);
   return CWinSystemBase::InitWindowSystem();
@@ -54,9 +64,14 @@ bool CWinSystemGbm::InitWindowSystem()
 
 bool CWinSystemGbm::DestroyWindowSystem()
 {
-  m_DRM.DestroyDrm();
+  m_GBM->DestroySurface();
+  m_nativeWindow = nullptr;
+
+  m_GBM->DestroyDevice();
   m_nativeDisplay = nullptr;
 
+  m_DRM->DestroyDrm();
+
   CLog::Log(LOGDEBUG, "CWinSystemGbm::%s - deinitialized DRM", __FUNCTION__);
   return true;
 }
@@ -65,19 +80,19 @@ bool CWinSystemGbm::CreateNewWindow(const std::string& name,
                                     bool fullScreen,
                                     RESOLUTION_INFO& res)
 {
-  if(!CDRMUtils::SetMode(res))
+  if(!m_DRM->SetMode(res))
   {
     CLog::Log(LOGERROR, "CWinSystemGbm::%s - failed to set DRM mode", __FUNCTION__);
     return false;
   }
 
-  if(!CGBMUtils::CreateSurface(&m_gbm, m_drm.mode->hdisplay, m_drm.mode->vdisplay))
+  if(!m_GBM->CreateSurface(m_DRM->m_mode->hdisplay, m_DRM->m_mode->vdisplay))
   {
     CLog::Log(LOGERROR, "CWinSystemGbm::%s - failed to initialize GBM", __FUNCTION__);
     return false;
   }
 
-  m_nativeWindow = m_gbm.surface;
+  m_nativeWindow = m_GBM->m_surface;
 
   CLog::Log(LOGDEBUG, "CWinSystemGbm::%s - initialized GBM", __FUNCTION__);
   return true;
@@ -85,7 +100,7 @@ bool CWinSystemGbm::CreateNewWindow(const std::string& name,
 
 bool CWinSystemGbm::DestroyWindow()
 {
-  CGBMUtils::DestroySurface(&m_gbm);
+  m_GBM->DestroySurface();
   m_nativeWindow = nullptr;
 
   CLog::Log(LOGDEBUG, "CWinSystemGbm::%s - deinitialized GBM", __FUNCTION__);
@@ -98,13 +113,13 @@ void CWinSystemGbm::UpdateResolutions()
 
   UpdateDesktopResolution(CDisplaySettings::GetInstance().GetResolutionInfo(RES_DESKTOP),
                           0,
-                          m_drm.mode->hdisplay,
-                          m_drm.mode->vdisplay,
-                          m_drm.mode->vrefresh);
+                          m_DRM->m_mode->hdisplay,
+                          m_DRM->m_mode->vdisplay,
+                          m_DRM->m_mode->vrefresh);
 
   std::vector<RESOLUTION_INFO> resolutions;
 
-  if (!CDRMUtils::GetModes(resolutions) || resolutions.empty())
+  if (!m_DRM->GetModes(resolutions) || resolutions.empty())
   {
     CLog::Log(LOGWARNING, "CWinSystemGbm::%s - Failed to get resolutions", __FUNCTION__);
   }
@@ -138,23 +153,31 @@ bool CWinSystemGbm::ResizeWindow(int newWidth, int newHeight, int newLeft, int n
 
 bool CWinSystemGbm::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays)
 {
-  if(!CDRMUtils::SetMode(res))
+  if(!m_DRM->SetMode(res))
   {
     CLog::Log(LOGERROR, "CWinSystemGbm::%s - failed to set DRM mode", __FUNCTION__);
     return false;
   }
 
-  return m_DRM.SetVideoMode(res);
+  struct gbm_bo *bo = m_GBM->LockFrontBuffer();
+  auto result = m_DRM->SetVideoMode(res, bo);
+  m_GBM->ReleaseBuffer();
+
+  return result;
 }
 
 void CWinSystemGbm::FlipPage()
 {
-  m_DRM.FlipPage();
+  struct gbm_bo *bo = m_GBM->LockFrontBuffer();
+
+  m_DRM->FlipPage(bo);
+
+  m_GBM->ReleaseBuffer();
 }
 
 void CWinSystemGbm::WaitVBlank()
 {
-  CDRMUtils::WaitVBlank();
+  m_DRM->WaitVBlank();
 }
 
 void* CWinSystemGbm::GetVaDisplay()
diff --git a/xbmc/windowing/gbm/WinSystemGbm.h b/xbmc/windowing/gbm/WinSystemGbm.h
index a99db9b405d4..ee814c29c0a6 100644
--- a/xbmc/windowing/gbm/WinSystemGbm.h
+++ b/xbmc/windowing/gbm/WinSystemGbm.h
@@ -25,7 +25,7 @@
 
 #include "threads/CriticalSection.h"
 #include "windowing/WinSystem.h"
-#include "DRM.h"
+#include "DRMUtils.h"
 #include "GLContextEGL.h"
 
 class IDispResource;
@@ -60,11 +60,10 @@ public:
   virtual void Register(IDispResource *resource);
   virtual void Unregister(IDispResource *resource);
 
-protected:
-  CDRM m_DRM;
+  std::shared_ptr<CDRMUtils> m_DRM;
 
-  gbm m_gbm;
-  drm m_drm;
+protected:
+  std::unique_ptr<CGBMUtils> m_GBM;
 
   EGLDisplay m_nativeDisplay;
   EGLNativeWindowType m_nativeWindow;
diff --git a/xbmc/windowing/gbm/WinSystemGbmGLESContext.cpp b/xbmc/windowing/gbm/WinSystemGbmGLESContext.cpp
index 9e3ad679ce78..34fed662b2fb 100644
--- a/xbmc/windowing/gbm/WinSystemGbmGLESContext.cpp
+++ b/xbmc/windowing/gbm/WinSystemGbmGLESContext.cpp
@@ -142,8 +142,8 @@ bool CWinSystemGbmGLESContext::CreateNewWindow(const std::string& name,
 
 bool CWinSystemGbmGLESContext::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays)
 {
-  if (res.iWidth != m_drm.mode->hdisplay ||
-      res.iHeight != m_drm.mode->vdisplay)
+  if (res.iWidth != m_DRM->m_mode->hdisplay ||
+      res.iHeight != m_DRM->m_mode->vdisplay)
   {
     CLog::Log(LOGDEBUG, "CWinSystemGbmGLESContext::%s - resolution changed, creating a new window", __FUNCTION__);
     CreateNewWindow("", fullScreen, res);

From 91a29c25854f61b61adf7795bc3d379cc6cad31d Mon Sep 17 00:00:00 2001
From: Lukas Rusak <lorusak@gmail.com>
Date: Tue, 12 Dec 2017 15:09:35 -0800
Subject: [PATCH 3/3] DRMPRIME: add windowing system into register function

---
 .../DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp      | 10 +++++-----
 .../DVDCodecs/Video/DVDVideoCodecDRMPRIME.h        |  1 +
 .../HwDecRender/RendererDRMPRIME.cpp               | 22 +++++++++++++---------
 .../VideoRenderers/HwDecRender/RendererDRMPRIME.h  |  7 +++++--
 xbmc/windowing/gbm/WinSystemGbmGLESContext.cpp     |  2 +-
 5 files changed, 25 insertions(+), 17 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp
index a8c053b63e8b..4ba0cd266553 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp
@@ -23,7 +23,9 @@
 #include "cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.h"
 #include "threads/SingleLock.h"
 #include "utils/log.h"
-#include "windowing/gbm/DRMUtils.h"
+
+#include <xf86drm.h>
+#include <xf86drmMode.h>
 
 extern "C" {
 #include "libavcodec/avcodec.h"
@@ -53,11 +55,9 @@ void CVideoBufferDRMPRIME::SetRef(AVFrame* frame)
 
 void CVideoBufferDRMPRIME::Unref()
 {
-  struct drm* drm = CDRMUtils::GetDrm();
-
   if (m_fb_id)
   {
-    drmModeRmFB(drm->fd, m_fb_id);
+    drmModeRmFB(m_drm_fd, m_fb_id);
     m_fb_id = 0;
   }
 
@@ -66,7 +66,7 @@ void CVideoBufferDRMPRIME::Unref()
     if (m_handles[i])
     {
       struct drm_gem_close gem_close = { .handle = m_handles[i] };
-      drmIoctl(drm->fd, DRM_IOCTL_GEM_CLOSE, &gem_close);
+      drmIoctl(m_drm_fd, DRM_IOCTL_GEM_CLOSE, &gem_close);
       m_handles[i] = 0;
     }
   }
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.h
index 3a94bd94e1c7..2041336ebca1 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.h
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.h
@@ -41,6 +41,7 @@ public:
   void SetRef(AVFrame* frame);
   void Unref();
 
+  uint32_t m_drm_fd = -1;
   uint32_t m_fb_id = 0;
   uint32_t m_handles[AV_DRM_MAX_PLANES] = {0};
 
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.cpp
index 652e1a6f5134..20861464a684 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.cpp
@@ -23,9 +23,11 @@
 #include "cores/VideoPlayer/VideoRenderers/RenderCapture.h"
 #include "cores/VideoPlayer/VideoRenderers/RenderFactory.h"
 #include "utils/log.h"
-#include "windowing/gbm/DRMUtils.h"
 
-CRendererDRMPRIME::CRendererDRMPRIME()
+static CWinSystemGbmGLESContext *m_pWinSystem;
+
+CRendererDRMPRIME::CRendererDRMPRIME(std::shared_ptr<CDRMUtils> drm)
+  : m_DRM(drm)
 {
 }
 
@@ -37,14 +39,15 @@ CRendererDRMPRIME::~CRendererDRMPRIME()
 CBaseRenderer* CRendererDRMPRIME::Create(CVideoBuffer* buffer)
 {
   if (buffer && dynamic_cast<CVideoBufferDRMPRIME*>(buffer))
-    return new CRendererDRMPRIME();
+    return new CRendererDRMPRIME(m_pWinSystem->m_DRM);
 
   return nullptr;
 }
 
-bool CRendererDRMPRIME::Register()
+bool CRendererDRMPRIME::Register(CWinSystemGbmGLESContext *winSystem)
 {
   VIDEOPLAYER::CRendererFactory::RegisterRenderer("drm_prime", CRendererDRMPRIME::Create);
+  m_pWinSystem = winSystem;
   return true;
 }
 
@@ -162,17 +165,18 @@ bool CRendererDRMPRIME::Supports(ESCALINGMETHOD method)
 
 void CRendererDRMPRIME::SetVideoPlane(CVideoBufferDRMPRIME* buffer)
 {
+  buffer->m_drm_fd = m_DRM->m_fd;
+
   AVDRMFrameDescriptor* descriptor = buffer->GetDescriptor();
   if (descriptor && descriptor->nb_layers)
   {
     uint32_t handles[4] = {0}, pitches[4] = {0}, offsets[4] = {0};
-    struct drm* drm = CDRMUtils::GetDrm();
     int ret;
 
     // convert Prime FD to GEM handle
     for (int object = 0; object < descriptor->nb_objects; object++)
     {
-      ret = drmPrimeFDToHandle(drm->fd, descriptor->objects[object].fd, &buffer->m_handles[object]);
+      ret = drmPrimeFDToHandle(m_DRM->m_fd, descriptor->objects[object].fd, &buffer->m_handles[object]);
       if (ret < 0)
       {
         CLog::Log(LOGERROR, "CRendererDRMPRIME::%s - failed to retrieve the GEM handle from prime fd %d, ret = %d", __FUNCTION__, descriptor->objects[object].fd, ret);
@@ -194,7 +198,7 @@ void CRendererDRMPRIME::SetVideoPlane(CVideoBufferDRMPRIME* buffer)
     }
 
     // add the video frame FB
-    ret = drmModeAddFB2(drm->fd, buffer->GetWidth(), buffer->GetHeight(), layer->format, handles, pitches, offsets, &buffer->m_fb_id, 0);
+    ret = drmModeAddFB2(m_DRM->m_fd, buffer->GetWidth(), buffer->GetHeight(), layer->format, handles, pitches, offsets, &buffer->m_fb_id, 0);
     if (ret < 0)
     {
       CLog::Log(LOGERROR, "CRendererDRMPRIME::%s - failed to add drm layer %d, ret = %d", __FUNCTION__, buffer->m_fb_id, ret);
@@ -213,12 +217,12 @@ void CRendererDRMPRIME::SetVideoPlane(CVideoBufferDRMPRIME* buffer)
     // TODO: use atomic or legacy api
 
     // show the video frame FB on the video plane
-    ret = drmModeSetPlane(drm->fd, drm->overlay_plane->plane->plane_id, drm->crtc->crtc->crtc_id, buffer->m_fb_id, 0,
+    ret = drmModeSetPlane(m_DRM->m_fd, m_DRM->m_overlay_plane->plane->plane_id, m_DRM->m_crtc->crtc->crtc_id, buffer->m_fb_id, 0,
                           crtc_x, crtc_y, crtc_w, crtc_h,
                           src_x, src_y, src_w, src_h);
     if (ret < 0)
     {
-      CLog::Log(LOGERROR, "CRendererDRMPRIME::%s - failed to set drm plane %d, buffer = %d, ret = %d", __FUNCTION__, drm->overlay_plane->plane->plane_id, buffer->m_fb_id, ret);
+      CLog::Log(LOGERROR, "CRendererDRMPRIME::%s - failed to set drm plane %d, buffer = %d, ret = %d", __FUNCTION__, m_DRM->m_overlay_plane->plane->plane_id, buffer->m_fb_id, ret);
       return;
     }
   }
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.h b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.h
index 5571c0ac2eac..09a450e9f8b1 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.h
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.h
@@ -24,17 +24,18 @@
 
 #include "cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.h"
 #include "cores/VideoPlayer/VideoRenderers/BaseRenderer.h"
+#include "windowing/gbm/WinSystemGbmGLESContext.h"
 
 class CRendererDRMPRIME
   : public CBaseRenderer
 {
 public:
-  CRendererDRMPRIME();
+  CRendererDRMPRIME(std::shared_ptr<CDRMUtils> drm);
   virtual ~CRendererDRMPRIME();
 
   // Registration
   static CBaseRenderer* Create(CVideoBuffer* buffer);
-  static bool Register();
+  static bool Register(CWinSystemGbmGLESContext *winSystem);
 
   // Player functions
   bool Configure(const VideoPicture& picture, float fps, unsigned flags, unsigned int orientation) override;
@@ -63,6 +64,8 @@ private:
   int m_iLastRenderBuffer = -1;
   static const int m_numRenderBuffers = 4;
 
+  std::shared_ptr<CDRMUtils> m_DRM;
+
   struct BUFFER
   {
     BUFFER() : videoBuffer(nullptr) {};
diff --git a/xbmc/windowing/gbm/WinSystemGbmGLESContext.cpp b/xbmc/windowing/gbm/WinSystemGbmGLESContext.cpp
index 34fed662b2fb..f4f9a16b61a0 100644
--- a/xbmc/windowing/gbm/WinSystemGbmGLESContext.cpp
+++ b/xbmc/windowing/gbm/WinSystemGbmGLESContext.cpp
@@ -87,7 +87,7 @@ bool CWinSystemGbmGLESContext::InitWindowSystem()
   }
 #endif
 
-  CRendererDRMPRIME::Register();
+  CRendererDRMPRIME::Register(this);
   CDVDVideoCodecDRMPRIME::Register();
 
   return true;
