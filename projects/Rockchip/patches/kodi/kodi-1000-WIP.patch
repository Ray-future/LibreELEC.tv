diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.cpp
index 5ea349c037..289e292a45 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.cpp
@@ -24,6 +24,7 @@
 #include "cores/VideoPlayer/VideoRenderers/RenderFactory.h"
 #include "utils/log.h"
 #include "windowing/gbm/DRMUtils.h"
+#include "windowing/gbm/DRMAtomic.h"
 
 CRendererDRMPRIME::CRendererDRMPRIME()
 {
@@ -210,16 +211,30 @@ void CRendererDRMPRIME::SetVideoPlane(CVideoBufferDRMPRIME* buffer)
     uint32_t src_w = buffer->GetWidth() << 16;
     uint32_t src_h = buffer->GetHeight() << 16;
 
-    // TODO: use atomic or legacy api
-
-    // show the video frame FB on the video plane
-    ret = drmModeSetPlane(drm->fd, drm->video_plane_id, drm->crtc_id, buffer->m_fb_id, 0,
-                          crtc_x, crtc_y, crtc_w, crtc_h,
-                          src_x, src_y, src_w, src_h);
-    if (ret < 0)
+    if(drm->req)
     {
-      CLog::Log(LOGERROR, "CRendererDRMPRIME::%s - failed to set drm plane %d, buffer = %d, ret = %d", __FUNCTION__, drm->video_plane_id, buffer->m_fb_id, ret);
-      return;
+      CDRMAtomic::AddPlaneProperty(drm->req, drm->primary_plane, "FB_ID",   buffer->m_fb_id);
+      CDRMAtomic::AddPlaneProperty(drm->req, drm->primary_plane, "CRTC_ID", drm->crtc_id);
+      CDRMAtomic::AddPlaneProperty(drm->req, drm->primary_plane, "SRC_X",   src_x);
+      CDRMAtomic::AddPlaneProperty(drm->req, drm->primary_plane, "SRC_Y",   src_y);
+      CDRMAtomic::AddPlaneProperty(drm->req, drm->primary_plane, "SRC_W",   src_w);
+      CDRMAtomic::AddPlaneProperty(drm->req, drm->primary_plane, "SRC_H",   src_h);
+      CDRMAtomic::AddPlaneProperty(drm->req, drm->primary_plane, "CRTC_X",  crtc_x);
+      CDRMAtomic::AddPlaneProperty(drm->req, drm->primary_plane, "CRTC_Y",  crtc_y);
+      CDRMAtomic::AddPlaneProperty(drm->req, drm->primary_plane, "CRTC_W",  crtc_w);
+      CDRMAtomic::AddPlaneProperty(drm->req, drm->primary_plane, "CRTC_H",  crtc_h);
+    }
+    else
+    {
+      // show the video frame FB on the video plane
+      ret = drmModeSetPlane(drm->fd, drm->primary_plane->plane->plane_id, drm->crtc_id, buffer->m_fb_id, 0,
+                            crtc_x, crtc_y, crtc_w, crtc_h,
+                            src_x, src_y, src_w, src_h);
+      if (ret < 0)
+      {
+        CLog::Log(LOGERROR, "CRendererDRMPRIME::%s - failed to set drm plane %d, buffer = %d, ret = %d", __FUNCTION__, drm->primary_plane->plane->plane_id, buffer->m_fb_id, ret);
+        return;
+      }
     }
   }
 }
diff --git a/xbmc/guilib/Resolution.cpp b/xbmc/guilib/Resolution.cpp
index d2cddb4e77..a86da11f4c 100644
--- a/xbmc/guilib/Resolution.cpp
+++ b/xbmc/guilib/Resolution.cpp
@@ -116,7 +116,7 @@ bool CResolutionUtils::FindResolutionFromOverride(float fps, int width, bool is3
                       override.fpsmin, override.fpsmax, override.refreshmin, override.refreshmax);
           }
 
-          weight = RefreshWeight(info.fRefreshRate, fps);
+          weight = RefreshWeight(info.fRefreshRate, fps, width);
 
           return true; //fps and refresh match with this override, use this resolution
         }
@@ -186,7 +186,7 @@ void CResolutionUtils::FindResolutionFromFpsMatch(float fps, int width, bool is3
         }
       }
 
-      weight = RefreshWeight(curr.fRefreshRate, fps);
+      weight = RefreshWeight(curr.fRefreshRate, fps, width);
     }
   }
 }
@@ -259,8 +259,8 @@ RESOLUTION CResolutionUtils::FindClosestResolution(float fps, int width, bool is
     }
     else
     {
-      int c_weight = MathUtils::round_int(RefreshWeight(curr.fRefreshRate, fRefreshRate * multiplier) * 10000.0);
-      int i_weight = MathUtils::round_int(RefreshWeight(info.fRefreshRate, fRefreshRate * multiplier) * 10000.0);
+      int c_weight = MathUtils::round_int(RefreshWeight(curr.fRefreshRate, fRefreshRate * multiplier, width) * 10000.0);
+      int i_weight = MathUtils::round_int(RefreshWeight(info.fRefreshRate, fRefreshRate * multiplier, width) * 10000.0);
 
       RESOLUTION current_bak = current;
       RESOLUTION_INFO curr_bak = curr;
@@ -294,13 +294,13 @@ RESOLUTION CResolutionUtils::FindClosestResolution(float fps, int width, bool is
   if (is3D)
     weight = 0;
   else
-    weight = RefreshWeight(curr.fRefreshRate, fRefreshRate * multiplier);
+    weight = RefreshWeight(curr.fRefreshRate, fRefreshRate * multiplier, width);
 
   return current;
 }
 
 //distance of refresh to the closest multiple of fps (multiple is 1 or higher), as a multiplier of fps
-float CResolutionUtils::RefreshWeight(float refresh, float fps)
+float CResolutionUtils::RefreshWeight(float refresh, float fps, int width)
 {
   float div   = refresh / fps;
   int   round = MathUtils::round_int(div);
@@ -318,7 +318,7 @@ float CResolutionUtils::RefreshWeight(float refresh, float fps)
   // the content is interlaced at the start, only
   // punish when refreshrate > 60 hz to not have to switch
   // twice for 30i content
-  if (refresh > 60 && round > 1)
+  if ((refresh > 60 || width > 1920) && round > 1)
     weight += round / 10000.0;
 
   return weight;
diff --git a/xbmc/guilib/Resolution.h b/xbmc/guilib/Resolution.h
index f571528a78..7faf3fbea8 100644
--- a/xbmc/guilib/Resolution.h
+++ b/xbmc/guilib/Resolution.h
@@ -105,5 +105,5 @@ protected:
   static bool FindResolutionFromOverride(float fps, int width, bool is3D, RESOLUTION &resolution, float& weight, bool fallback);
   static void FindResolutionFromFpsMatch(float fps, int width, bool is3D, RESOLUTION &resolution, float& weight);
   static RESOLUTION FindClosestResolution(float fps, int width, bool is3D, float multiplier, RESOLUTION current, float& weight);
-  static float RefreshWeight(float refresh, float fps);
+  static float RefreshWeight(float refresh, float fps, int width);
 };
diff --git a/xbmc/windowing/gbm/DRM.cpp b/xbmc/windowing/gbm/DRM.cpp
index 7324ee580a..b776f0b14e 100644
--- a/xbmc/windowing/gbm/DRM.cpp
+++ b/xbmc/windowing/gbm/DRM.cpp
@@ -29,11 +29,11 @@ CDRM::CDRM()
 {
 }
 
-void CDRM::FlipPage()
+void CDRM::FlipPage(bool rendered, bool videoLayer)
 {
   if (m_atomic)
   {
-    CDRMAtomic::FlipPage();
+    CDRMAtomic::FlipPage(rendered, videoLayer);
   }
   else
   {
diff --git a/xbmc/windowing/gbm/DRM.h b/xbmc/windowing/gbm/DRM.h
index 5317396b48..65fe981d87 100644
--- a/xbmc/windowing/gbm/DRM.h
+++ b/xbmc/windowing/gbm/DRM.h
@@ -28,7 +28,7 @@ class CDRM
 public:
   CDRM();
   ~CDRM() = default;
-  void FlipPage();
+  void FlipPage(bool rendered, bool videoLayer);
   bool SetVideoMode(RESOLUTION_INFO res);
   bool InitDrm(drm *drm, gbm *gbm);
   void DestroyDrm();
diff --git a/xbmc/windowing/gbm/DRMAtomic.cpp b/xbmc/windowing/gbm/DRMAtomic.cpp
index 8378204a27..dfeff6706b 100644
--- a/xbmc/windowing/gbm/DRMAtomic.cpp
+++ b/xbmc/windowing/gbm/DRMAtomic.cpp
@@ -95,9 +95,8 @@ bool CDRMAtomic::AddCrtcProperty(drmModeAtomicReq *req, int obj_id, const char *
   return true;
 }
 
-bool CDRMAtomic::AddPlaneProperty(drmModeAtomicReq *req, int obj_id, const char *name, int value)
+bool CDRMAtomic::AddPlaneProperty(drmModeAtomicReq *req, struct plane *obj, const char *name, int value)
 {
-  struct plane *obj = m_drm->plane;
   int prop_id = -1;
 
   for (unsigned int i = 0 ; i < obj->props->count_props ; i++)
@@ -115,7 +114,7 @@ bool CDRMAtomic::AddPlaneProperty(drmModeAtomicReq *req, int obj_id, const char
     return false;
   }
 
-  auto ret = drmModeAtomicAddProperty(req, obj_id, prop_id, value);
+  auto ret = drmModeAtomicAddProperty(req, obj->plane->plane_id, prop_id, value);
   if (ret < 0)
   {
     return false;
@@ -124,17 +123,14 @@ bool CDRMAtomic::AddPlaneProperty(drmModeAtomicReq *req, int obj_id, const char
   return true;
 }
 
-bool CDRMAtomic::DrmAtomicCommit(int fb_id, int flags)
+bool CDRMAtomic::DrmAtomicCommit(int fb_id, int flags, bool rendered, bool videoLayer)
 {
-  drmModeAtomicReq *req;
-  int plane_id = m_drm->plane->plane->plane_id;
   uint32_t blob_id;
-
-  req = drmModeAtomicAlloc();
+  struct plane *plane;
 
   if (flags & DRM_MODE_ATOMIC_ALLOW_MODESET)
   {
-    if (!AddConnectorProperty(req, m_drm->connector_id, "CRTC_ID", m_drm->crtc_id))
+    if (!AddConnectorProperty(m_drm->req, m_drm->connector_id, "CRTC_ID", m_drm->crtc_id))
     {
       return false;
     }
@@ -144,38 +140,64 @@ bool CDRMAtomic::DrmAtomicCommit(int fb_id, int flags)
       return false;
     }
 
-    if (!AddCrtcProperty(req, m_drm->crtc_id, "MODE_ID", blob_id))
+    if (!AddCrtcProperty(m_drm->req, m_drm->crtc_id, "MODE_ID", blob_id))
     {
       return false;
     }
 
-    if (!AddCrtcProperty(req, m_drm->crtc_id, "ACTIVE", 1))
+    if (!AddCrtcProperty(m_drm->req, m_drm->crtc_id, "ACTIVE", 1))
     {
       return false;
     }
+
+    if (!videoLayer)
+    {
+      // disable overlay plane on modeset
+      AddPlaneProperty(m_drm->req, m_drm->overlay_plane, "FB_ID", 0);
+      AddPlaneProperty(m_drm->req, m_drm->overlay_plane, "CRTC_ID", 0);
+    }
   }
 
-  AddPlaneProperty(req, plane_id, "FB_ID", fb_id);
-  AddPlaneProperty(req, plane_id, "CRTC_ID", m_drm->crtc_id);
-  AddPlaneProperty(req, plane_id, "SRC_X", 0);
-  AddPlaneProperty(req, plane_id, "SRC_Y", 0);
-  AddPlaneProperty(req, plane_id, "SRC_W", m_drm->mode->hdisplay << 16);
-  AddPlaneProperty(req, plane_id, "SRC_H", m_drm->mode->vdisplay << 16);
-  AddPlaneProperty(req, plane_id, "CRTC_X", 0);
-  AddPlaneProperty(req, plane_id, "CRTC_Y", 0);
-  AddPlaneProperty(req, plane_id, "CRTC_W", m_drm->mode->hdisplay);
-  AddPlaneProperty(req, plane_id, "CRTC_H", m_drm->mode->vdisplay);
+  if (videoLayer)
+    plane = m_drm->overlay_plane;
+  else
+    plane = m_drm->primary_plane;
+
+  if (rendered)
+  {
+    AddPlaneProperty(m_drm->req, plane, "FB_ID", fb_id);
+    AddPlaneProperty(m_drm->req, plane, "CRTC_ID", m_drm->crtc_id);
+    AddPlaneProperty(m_drm->req, plane, "SRC_X", 0);
+    AddPlaneProperty(m_drm->req, plane, "SRC_Y", 0);
+    AddPlaneProperty(m_drm->req, plane, "SRC_W", m_drm->mode->hdisplay << 16);
+    AddPlaneProperty(m_drm->req, plane, "SRC_H", m_drm->mode->vdisplay << 16);
+    AddPlaneProperty(m_drm->req, plane, "CRTC_X", 0);
+    AddPlaneProperty(m_drm->req, plane, "CRTC_Y", 0);
+    AddPlaneProperty(m_drm->req, plane, "CRTC_W", m_drm->mode->hdisplay);
+    AddPlaneProperty(m_drm->req, plane, "CRTC_H", m_drm->mode->vdisplay);
+  }
+  else if (videoLayer)
+  {
+    // disable gui plane when video layer is active and nothing is rendered
+    // TODO: only disable when no control is visible
+    AddPlaneProperty(m_drm->req, plane, "FB_ID", 0);
+    AddPlaneProperty(m_drm->req, plane, "CRTC_ID", 0);
+  }
 
-  auto ret = drmModeAtomicCommit(m_drm->fd, req, flags, nullptr);
+  auto ret = drmModeAtomicCommit(m_drm->fd, m_drm->req, flags, nullptr);
   if (ret)
   {
     return false;
   }
 
+  drmModeAtomicFree(m_drm->req);
+
+  m_drm->req = drmModeAtomicAlloc();
+
   return true;
 }
 
-void CDRMAtomic::FlipPage()
+void CDRMAtomic::FlipPage(bool rendered, bool videoLayer)
 {
   uint32_t flags = 0;
 
@@ -185,31 +207,34 @@ void CDRMAtomic::FlipPage()
     m_drm->need_modeset = false;
   }
 
-  gbm_surface_release_buffer(m_gbm->surface, m_bo);
-  m_bo = m_next_bo;
-
-  m_next_bo = gbm_surface_lock_front_buffer(m_gbm->surface);
-  if (!m_next_bo)
+  if (rendered)
   {
-    CLog::Log(LOGERROR, "CDRMAtomic::%s - Failed to lock frontbuffer", __FUNCTION__);
-    return;
-  }
+    gbm_surface_release_buffer(m_gbm->surface, m_bo);
+    m_bo = m_next_bo;
 
-  m_drm_fb = CDRMUtils::DrmFbGetFromBo(m_next_bo);
-  if (!m_drm_fb)
-  {
-    CLog::Log(LOGERROR, "CDRMAtomic::%s - Failed to get a new FBO", __FUNCTION__);
-    return;
+    m_next_bo = gbm_surface_lock_front_buffer(m_gbm->surface);
+    if (!m_next_bo)
+    {
+      CLog::Log(LOGERROR, "CDRMAtomic::%s - Failed to lock frontbuffer", __FUNCTION__);
+      return;
+    }
+
+    m_drm_fb = CDRMUtils::DrmFbGetFromBo(m_next_bo);
+    if (!m_drm_fb)
+    {
+      CLog::Log(LOGERROR, "CDRMAtomic::%s - Failed to get a new FBO", __FUNCTION__);
+      return;
+    }
   }
 
-  auto ret = DrmAtomicCommit(m_drm_fb->fb_id, flags);
+  auto ret = DrmAtomicCommit(m_drm_fb->fb_id, flags, rendered, videoLayer);
   if (!ret) {
     CLog::Log(LOGERROR, "CDRMAtomic::%s - failed to commit: %s", __FUNCTION__, strerror(errno));
     return;
   }
 }
 
-int CDRMAtomic::GetPlaneId()
+int CDRMAtomic::GetPlaneId(uint32_t type)
 {
   drmModePlaneResPtr plane_resources;
   int ret = -EINVAL;
@@ -243,7 +268,7 @@ int CDRMAtomic::GetPlaneId()
       {
         drmModePropertyPtr p = drmModeGetProperty(m_drm->fd, props->props[j]);
 
-        if ((strcmp(p->name, "type") == 0) && (props->prop_values[j] == DRM_PLANE_TYPE_PRIMARY))
+        if ((strcmp(p->name, "type") == 0) && (props->prop_values[j] == type))
         {
           /* found our primary plane, lets use that: */
           found_primary = 1;
@@ -276,6 +301,13 @@ bool CDRMAtomic::InitDrmAtomic(drm *drm, gbm *gbm)
     return false;
   }
 
+  ret = drmSetClientCap(m_drm->fd, DRM_CLIENT_CAP_UNIVERSAL_PLANES, 1);
+  if (ret)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - failed to set universal planes capability: %s", __FUNCTION__, strerror(errno));
+    return false;
+  }
+
   ret = drmSetClientCap(m_drm->fd, DRM_CLIENT_CAP_ATOMIC, 1);
   if (ret)
   {
@@ -283,44 +315,79 @@ bool CDRMAtomic::InitDrmAtomic(drm *drm, gbm *gbm)
     return false;
   }
 
-  ret = GetPlaneId();
+  /* We only do single plane to single crtc to single connector, no
+     * fancy multi-monitor.  So just grab the
+     * plane/crtc/connector property info for one of each:
+     */
+  m_drm->primary_plane = new plane;
+  m_drm->overlay_plane = new plane;
+  m_drm->crtc = new crtc;
+  m_drm->connector = new connector;
+
+  // primary plane
+  ret = GetPlaneId(DRM_PLANE_TYPE_PRIMARY);
   if (!ret)
   {
-    CLog::Log(LOGERROR, "CDRMAtomic::%s - could not find a suitable plane", __FUNCTION__);
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - could not find a suitable primary plane", __FUNCTION__);
     return false;
   }
   else
   {
+    CLog::Log(LOGDEBUG, "CDRMAtomic::%s - primary plane %d", __FUNCTION__, ret);
     plane_id = ret;
   }
 
-  /* We only do single plane to single crtc to single connector, no
-     * fancy multi-monitor or multi-plane stuff.  So just grab the
-     * plane/crtc/connector property info for one of each:
-     */
-  m_drm->plane = new plane;
-  m_drm->crtc = new crtc;
-  m_drm->connector = new connector;
+  m_drm->primary_plane->plane = drmModeGetPlane(m_drm->fd, plane_id);
+  if (!m_drm->primary_plane->plane)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - could not get plane %i: %s", __FUNCTION__, plane_id, strerror(errno));
+    return false;
+  }
 
-  // plane
-  m_drm->plane->plane = drmModeGetPlane(m_drm->fd, plane_id);
-  if (!m_drm->plane->plane)
+  m_drm->primary_plane->props = drmModeObjectGetProperties(m_drm->fd, plane_id, DRM_MODE_OBJECT_PLANE);
+  if (!m_drm->primary_plane->props)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - could not get plane %u properties: %s", __FUNCTION__, plane_id, strerror(errno));
+    return false;
+  }
+
+  m_drm->primary_plane->props_info = new drmModePropertyPtr;
+  for (uint32_t i = 0; i < m_drm->primary_plane->props->count_props; i++)
+  {
+    m_drm->primary_plane->props_info[i] = drmModeGetProperty(m_drm->fd, m_drm->primary_plane->props->props[i]);
+  }
+
+  // overlay plane
+  ret = GetPlaneId(DRM_PLANE_TYPE_OVERLAY);
+  if (!ret)
+  {
+    CLog::Log(LOGERROR, "CDRMAtomic::%s - could not find a suitable overlay plane", __FUNCTION__);
+    return false;
+  }
+  else
+  {
+    CLog::Log(LOGDEBUG, "CDRMAtomic::%s - overlay plane %d", __FUNCTION__, ret);
+    plane_id = ret;
+  }
+
+  m_drm->overlay_plane->plane = drmModeGetPlane(m_drm->fd, plane_id);
+  if (!m_drm->overlay_plane->plane)
   {
     CLog::Log(LOGERROR, "CDRMAtomic::%s - could not get plane %i: %s", __FUNCTION__, plane_id, strerror(errno));
     return false;
   }
 
-  m_drm->plane->props = drmModeObjectGetProperties(m_drm->fd, plane_id, DRM_MODE_OBJECT_PLANE);
-  if (!m_drm->plane->props)
+  m_drm->overlay_plane->props = drmModeObjectGetProperties(m_drm->fd, plane_id, DRM_MODE_OBJECT_PLANE);
+  if (!m_drm->overlay_plane->props)
   {
     CLog::Log(LOGERROR, "CDRMAtomic::%s - could not get plane %u properties: %s", __FUNCTION__, plane_id, strerror(errno));
     return false;
   }
 
-  m_drm->plane->props_info = new drmModePropertyPtr;
-  for (uint32_t i = 0; i < m_drm->plane->props->count_props; i++)
+  m_drm->overlay_plane->props_info = new drmModePropertyPtr;
+  for (uint32_t i = 0; i < m_drm->overlay_plane->props->count_props; i++)
   {
-    m_drm->plane->props_info[i] = drmModeGetProperty(m_drm->fd, m_drm->plane->props->props[i]);             \
+    m_drm->overlay_plane->props_info[i] = drmModeGetProperty(m_drm->fd, m_drm->overlay_plane->props->props[i]);
   }
 
   // crtc
@@ -365,7 +432,6 @@ bool CDRMAtomic::InitDrmAtomic(drm *drm, gbm *gbm)
     m_drm->connector->props_info[i] = drmModeGetProperty(m_drm->fd, m_drm->connector->props->props[i]);             \
   }
 
-  //
   m_gbm->dev = gbm_create_device(m_drm->fd);
 
   if (!CGBMUtils::InitGbm(m_gbm, m_drm->mode->hdisplay, m_drm->mode->vdisplay))
@@ -373,6 +439,8 @@ bool CDRMAtomic::InitDrmAtomic(drm *drm, gbm *gbm)
     return false;
   }
 
+  m_drm->req = drmModeAtomicAlloc();
+
   return true;
 }
 
@@ -389,6 +457,8 @@ void CDRMAtomic::DestroyDrmAtomic()
   {
     gbm_device_destroy(m_gbm->dev);
   }
+
+  drmModeAtomicFree(m_drm->req);
 }
 
 bool CDRMAtomic::SetVideoMode(RESOLUTION_INFO res)
diff --git a/xbmc/windowing/gbm/DRMAtomic.h b/xbmc/windowing/gbm/DRMAtomic.h
index 09f6230580..c7535f9ce8 100644
--- a/xbmc/windowing/gbm/DRMAtomic.h
+++ b/xbmc/windowing/gbm/DRMAtomic.h
@@ -25,7 +25,8 @@
 class CDRMAtomic : public CDRMUtils
 {
 public:
-  static void FlipPage();
+  static bool AddPlaneProperty(drmModeAtomicReq *req, struct plane *obj, const char *name, int value);
+  static void FlipPage(bool rendered, bool videoLayer);
   static bool SetVideoMode(RESOLUTION_INFO res);
   static bool InitDrmAtomic(drm *drm, gbm *gbm);
   static void DestroyDrmAtomic();
@@ -33,7 +34,6 @@ public:
 private:
   static bool AddConnectorProperty(drmModeAtomicReq *req, int obj_id, const char *name, int value);
   static bool AddCrtcProperty(drmModeAtomicReq *req, int obj_id, const char *name, int value);
-  static bool AddPlaneProperty(drmModeAtomicReq *req, int obj_id, const char *name, int value);
-  static bool DrmAtomicCommit(int fb_id, int flags);
-  static int GetPlaneId();
+  static bool DrmAtomicCommit(int fb_id, int flags, bool rendered, bool videoLayer);
+  static int GetPlaneId(uint32_t type);
 };
diff --git a/xbmc/windowing/gbm/DRMUtils.cpp b/xbmc/windowing/gbm/DRMUtils.cpp
index 2ce1f3e70c..5600ef9591 100644
--- a/xbmc/windowing/gbm/DRMUtils.cpp
+++ b/xbmc/windowing/gbm/DRMUtils.cpp
@@ -32,6 +32,7 @@
 #include "WinSystemGbmGLESContext.h"
 #include "guilib/gui3d.h"
 #include "utils/log.h"
+#include "utils/StringUtils.h"
 
 #include "DRMUtils.h"
 
@@ -437,7 +438,6 @@ bool CDRMUtils::GetModes(std::vector<RESOLUTION_INFO> &resolutions)
     res.iSubtitles = static_cast<int>(0.965 * res.iHeight);
     res.fPixelRatio = 1.0f;
     res.bFullScreen = true;
-    res.strMode = m_drm_connector->modes[i].name;
     res.strId = std::to_string(i);
 
     if(m_drm_connector->modes[i].flags & DRM_MODE_FLAG_3D_MASK)
@@ -461,6 +461,8 @@ bool CDRMUtils::GetModes(std::vector<RESOLUTION_INFO> &resolutions)
       res.dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
     }
 
+    res.strMode = StringUtils::Format("%dx%d%s @ %.6f Hz", res.iScreenWidth, res.iScreenHeight,
+                                      res.dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "", res.fRefreshRate);
     resolutions.push_back(res);
   }
 
diff --git a/xbmc/windowing/gbm/DRMUtils.h b/xbmc/windowing/gbm/DRMUtils.h
index 6e401f4b5b..4594a08f28 100644
--- a/xbmc/windowing/gbm/DRMUtils.h
+++ b/xbmc/windowing/gbm/DRMUtils.h
@@ -54,7 +54,8 @@ struct drm
   int fd;
 
   /* only used for atomic: */
-  struct plane *plane;
+  struct plane *primary_plane;
+  struct plane *overlay_plane;
   struct crtc *crtc;
   struct connector *connector;
   int crtc_index;
@@ -65,6 +66,8 @@ struct drm
   uint32_t video_plane_id;
 
   bool need_modeset;
+
+  drmModeAtomicReq *req;
 };
 
 struct drm_fb
diff --git a/xbmc/windowing/gbm/WinSystemGbm.cpp b/xbmc/windowing/gbm/WinSystemGbm.cpp
index 42edf5bcff..31e8215d85 100644
--- a/xbmc/windowing/gbm/WinSystemGbm.cpp
+++ b/xbmc/windowing/gbm/WinSystemGbm.cpp
@@ -150,9 +150,9 @@ bool CWinSystemGbm::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool bl
   return true;
 }
 
-void CWinSystemGbm::FlipPage()
+void CWinSystemGbm::FlipPage(bool rendered, bool videoLayer)
 {
-  m_DRM.FlipPage();
+  m_DRM.FlipPage(rendered, videoLayer);
 }
 
 void CWinSystemGbm::WaitVBlank()
diff --git a/xbmc/windowing/gbm/WinSystemGbm.h b/xbmc/windowing/gbm/WinSystemGbm.h
index 2d29c932fc..9c26b3f631 100644
--- a/xbmc/windowing/gbm/WinSystemGbm.h
+++ b/xbmc/windowing/gbm/WinSystemGbm.h
@@ -48,7 +48,7 @@ public:
   bool ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop) override;
   bool SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays) override;
 
-  void FlipPage();
+  void FlipPage(bool rendered, bool videoLayer);
   void WaitVBlank();
 
   void UpdateResolutions() override;
diff --git a/xbmc/windowing/gbm/WinSystemGbmGLESContext.cpp b/xbmc/windowing/gbm/WinSystemGbmGLESContext.cpp
index 0bcd6f0953..3ec31a8f53 100644
--- a/xbmc/windowing/gbm/WinSystemGbmGLESContext.cpp
+++ b/xbmc/windowing/gbm/WinSystemGbmGLESContext.cpp
@@ -145,10 +145,11 @@ void CWinSystemGbmGLESContext::PresentRender(bool rendered, bool videoLayer)
   if (!m_bRenderCreated)
     return;
 
-  if (rendered)
+  if (rendered || videoLayer)
   {
-    m_pGLContext.SwapBuffers();
-    CWinSystemGbm::FlipPage();
+    if (rendered)
+      m_pGLContext.SwapBuffers();
+    CWinSystemGbm::FlipPage(rendered, videoLayer);
   }
   else
   {
