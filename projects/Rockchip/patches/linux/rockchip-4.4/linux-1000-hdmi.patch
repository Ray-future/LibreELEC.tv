diff --git a/drivers/gpu/drm/drm_atomic_helper.c b/drivers/gpu/drm/drm_atomic_helper.c
index c4e41eda1706..8da8db6db5f1 100644
--- a/drivers/gpu/drm/drm_atomic_helper.c
+++ b/drivers/gpu/drm/drm_atomic_helper.c
@@ -2188,11 +2188,11 @@ int __drm_atomic_helper_set_config(struct drm_mode_set *set,
 	primary_state->src_x = set->x << 16;
 	primary_state->src_y = set->y << 16;
 	if (primary_state->rotation & (BIT(DRM_ROTATE_90) | BIT(DRM_ROTATE_270))) {
-		primary_state->src_h = set->fb->width << 16;
-		primary_state->src_w = set->fb->height << 16;
+		primary_state->src_h = hdisplay << 16;
+		primary_state->src_w = vdisplay << 16;
 	} else {
-		primary_state->src_h = set->fb->height << 16;
-		primary_state->src_w = set->fb->width << 16;
+		primary_state->src_h = vdisplay << 16;
+		primary_state->src_w = hdisplay << 16;
 	}
 
 commit:
diff --git a/drivers/gpu/drm/drm_crtc.c b/drivers/gpu/drm/drm_crtc.c
index 365e3d588163..7cd13faf83ca 100644
--- a/drivers/gpu/drm/drm_crtc.c
+++ b/drivers/gpu/drm/drm_crtc.c
@@ -2931,8 +2931,6 @@ int drm_crtc_check_viewport(const struct drm_crtc *crtc,
 
 {
 	int hdisplay, vdisplay;
-	pr_info("%s: skip check\n", __func__);
-	return 0;
 
 	drm_crtc_get_hv_timing(mode, &hdisplay, &vdisplay);
 
diff --git a/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c b/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
index 6ef8f7c16db3..a7dabfed4e96 100644
--- a/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
+++ b/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
@@ -444,9 +444,6 @@ dw_hdmi_rockchip_mode_valid(struct drm_connector *connector,
 	    !drm_mode_is_420(&connector->display_info, mode))
 		return MODE_BAD;
 
-	if (mode->clock > 297000)
-		return MODE_BAD;
-
 	if (!encoder) {
 		const struct drm_connector_helper_funcs *funcs;
 
@@ -465,6 +462,11 @@ dw_hdmi_rockchip_mode_valid(struct drm_connector *connector,
 	if (hdmi->dev_type == RK3368_HDMI && mode->clock > 340000 &&
 	    !drm_mode_is_420(&connector->display_info, mode))
 		return MODE_BAD;
+
+	/* Skip 4k 50/60hz modes for RK3288 */
+	if (hdmi->dev_type == RK3288_HDMI && mode->clock > 340000)
+		return MODE_BAD;
+
 	/*
 	 * ensure all drm display mode can work, if someone want support more
 	 * resolutions, please limit the possible_crtc, only connect to
@@ -627,6 +629,10 @@ dw_hdmi_rockchip_select_output(struct drm_connector_state *conn_state,
 	struct drm_display_info *info = &conn_state->connector->display_info;
 	struct drm_display_mode *mode = &crtc_state->mode;
 
+	/* Force YCbCr LQ output for RK3328 */
+	if (hdmi->dev_type == RK3328_HDMI)
+		hdmi->hdmi_output = DRM_HDMI_OUTPUT_YCBCR_LQ;
+
 	*color_format = DRM_HDMI_OUTPUT_DEFAULT_RGB;
 
 	switch (hdmi->hdmi_output) {
diff --git a/drivers/gpu/drm/rockchip/rockchip_vop_reg.c b/drivers/gpu/drm/rockchip/rockchip_vop_reg.c
index 6fbdc9701e97..9a70cddd3ce3 100644
--- a/drivers/gpu/drm/rockchip/rockchip_vop_reg.c
+++ b/drivers/gpu/drm/rockchip/rockchip_vop_reg.c
@@ -281,9 +281,9 @@ static const struct vop_ctrl rk3288_ctrl_data = {
  */
 static const struct vop_win_data rk3288_vop_win_data[] = {
 	{ .base = 0x00, .phy = &rk3288_win01_data,
-	  .type = DRM_PLANE_TYPE_OVERLAY },
-	{ .base = 0x40, .phy = &rk3288_win01_data,
 	  .type = DRM_PLANE_TYPE_PRIMARY },
+	{ .base = 0x40, .phy = &rk3288_win01_data,
+	  .type = DRM_PLANE_TYPE_OVERLAY },
 	{ .base = 0x00, .phy = &rk3288_win23_data,
 	  .type = DRM_PLANE_TYPE_OVERLAY,
 	  .area = rk3288_area_data,
@@ -974,10 +974,10 @@ static const struct vop_csc rk3328_win2_csc = {
 
 static const struct vop_win_data rk3328_vop_win_data[] = {
 	{ .base = 0xd0, .phy = &rk3288_win01_data,  .csc = &rk3328_win0_csc,
-	  .type = DRM_PLANE_TYPE_OVERLAY,
+	  .type = DRM_PLANE_TYPE_PRIMARY,
 	  .feature = WIN_FEATURE_HDR2SDR | WIN_FEATURE_SDR2HDR },
 	{ .base = 0x1d0, .phy = &rk3288_win01_data, .csc = &rk3328_win1_csc,
-	  .type = DRM_PLANE_TYPE_PRIMARY,
+	  .type = DRM_PLANE_TYPE_OVERLAY,
 	  .feature = WIN_FEATURE_SDR2HDR | WIN_FEATURE_PRE_OVERLAY },
 	{ .base = 0x2d0, .phy = &rk3288_win01_data, .csc = &rk3328_win2_csc,
 	  .type = DRM_PLANE_TYPE_CURSOR,
